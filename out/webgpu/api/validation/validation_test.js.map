{"version":3,"sources":["../../../../src/webgpu/api/validation/validation_test.ts"],"names":["assert","unreachable","kMaxQueryCount","GPUTest","CommandBufferMaker","ValidationTest","createTextureWithState","state","descriptor","size","width","height","depthOrArrayLayers","format","usage","GPUTextureUsage","COPY_SRC","COPY_DST","SAMPLED","STORAGE","RENDER_ATTACHMENT","device","createTexture","getErrorTexture","texture","destroy","createBufferWithState","GPUBufferUsage","VERTEX","createBuffer","pushErrorScope","buffer","MAP_READ","popErrorScope","createQuerySetWithState","desc","type","count","createQuerySet","expectGPUError","queryset","getStorageBuffer","getUniformBuffer","UNIFORM","getErrorBuffer","getErrorSampler","sampler","createSampler","lodMinClamp","getSampledTexture","sampleCount","getStorageTexture","getRenderTexture","getErrorTextureView","view","createView","getBindingResource","bindingType","minFilter","compare","createRenderPipelineWithState","createNoOpRenderPipeline","createErrorRenderPipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","pipeline","createNoOpComputePipeline","createComputePipeline","compute","createErrorComputePipeline","createEncoder","encoderType","attachmentInfo","occlusionQuerySet","fullAttachmentInfo","colorFormats","encoder","createCommandEncoder","shouldSucceed","finish","rbEncoder","createRenderBundleEncoder","pass","rb","executeBundles","validateFinish","commandEncoder","beginComputePass","endPass","makeAttachmentView","passDesc","colorAttachments","Array","from","loadValue","storeOp","depthStencilAttachment","depthStencilFormat","undefined","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","beginRenderPass","expectValidationError","fn","shouldError","returnValue","promise","eventualAsyncExpectation","niceStack","gpuValidationError","message","rec","validationFailed","GPUValidationError","debug"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../../common/util/util.js';\nimport { BindableResource, kMaxQueryCount } from '../../capability_info.js';\nimport { GPUTest } from '../../gpu_test.js';\n\nimport { CommandBufferMaker, EncoderType } from './util/command_buffer_maker.js';\n\nexport type ResourceState = 'valid' | 'invalid' | 'destroyed';\n\n/**\n * Base fixture for WebGPU validation tests.\n */\nexport class ValidationTest extends GPUTest {\n  /**\n   * Create a GPUTexture in the specified state.\n   * A `descriptor` may optionally be passed, which is used when `state` is not `'invalid'`.\n   */\n  createTextureWithState(\n    state: ResourceState,\n    descriptor?: Readonly<GPUTextureDescriptor>\n  ): GPUTexture {\n    descriptor = descriptor ?? {\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.SAMPLED |\n        GPUTextureUsage.STORAGE |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    };\n\n    switch (state) {\n      case 'valid':\n        return this.device.createTexture(descriptor);\n      case 'invalid':\n        return this.getErrorTexture();\n      case 'destroyed': {\n        const texture = this.device.createTexture(descriptor);\n        texture.destroy();\n        return texture;\n      }\n    }\n  }\n\n  /**\n   * Create a GPUTexture in the specified state. A `descriptor` may optionally be passed;\n   * if `state` is `'invalid'`, it will be modified to add an invalid combination of usages.\n   */\n  createBufferWithState(\n    state: ResourceState,\n    descriptor?: Readonly<GPUBufferDescriptor>\n  ): GPUBuffer {\n    descriptor = descriptor ?? {\n      size: 4,\n      usage: GPUBufferUsage.VERTEX,\n    };\n\n    switch (state) {\n      case 'valid':\n        return this.device.createBuffer(descriptor);\n\n      case 'invalid': {\n        // Make the buffer invalid because of an invalid combination of usages but keep the\n        // descriptor passed as much as possible (for mappedAtCreation and friends).\n        this.device.pushErrorScope('validation');\n        const buffer = this.device.createBuffer({\n          ...descriptor,\n          usage: descriptor.usage | GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_SRC,\n        });\n        this.device.popErrorScope();\n        return buffer;\n      }\n      case 'destroyed': {\n        const buffer = this.device.createBuffer(descriptor);\n        buffer.destroy();\n        return buffer;\n      }\n    }\n  }\n\n  /**\n   * Create a GPUQuerySet in the specified state.\n   * A `descriptor` may optionally be passed, which is used when `state` is not `'invalid'`.\n   */\n  createQuerySetWithState(\n    state: ResourceState,\n    desc?: Readonly<GPUQuerySetDescriptor>\n  ): GPUQuerySet {\n    const descriptor = { type: 'occlusion' as const, count: 2, ...desc };\n\n    switch (state) {\n      case 'valid':\n        return this.device.createQuerySet(descriptor);\n      case 'invalid': {\n        // Make the queryset invalid because of the count out of bounds.\n        descriptor.count = kMaxQueryCount + 1;\n        return this.expectGPUError('validation', () => this.device.createQuerySet(descriptor));\n      }\n      case 'destroyed': {\n        const queryset = this.device.createQuerySet(descriptor);\n        queryset.destroy();\n        return queryset;\n      }\n    }\n  }\n\n  /** Create an arbitrarily-sized GPUBuffer with the STORAGE usage. */\n  getStorageBuffer(): GPUBuffer {\n    return this.device.createBuffer({ size: 1024, usage: GPUBufferUsage.STORAGE });\n  }\n\n  /** Create an arbitrarily-sized GPUBuffer with the UNIFORM usage. */\n  getUniformBuffer(): GPUBuffer {\n    return this.device.createBuffer({ size: 1024, usage: GPUBufferUsage.UNIFORM });\n  }\n\n  /** Return an invalid GPUBuffer. */\n  getErrorBuffer(): GPUBuffer {\n    return this.createBufferWithState('invalid');\n  }\n\n  /** Return an invalid GPUSampler. */\n  getErrorSampler(): GPUSampler {\n    this.device.pushErrorScope('validation');\n    const sampler = this.device.createSampler({ lodMinClamp: -1 });\n    this.device.popErrorScope();\n    return sampler;\n  }\n\n  /**\n   * Return an arbitrarily-configured GPUTexture with the `SAMPLED` usage and specified sampleCount.\n   */\n  getSampledTexture(sampleCount: number = 1): GPUTexture {\n    return this.device.createTexture({\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.SAMPLED,\n      sampleCount,\n    });\n  }\n\n  /** Return an arbitrarily-configured GPUTexture with the `STORAGE` usage. */\n  getStorageTexture(): GPUTexture {\n    return this.device.createTexture({\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.STORAGE,\n    });\n  }\n\n  /** Return an arbitrarily-configured GPUTexture with the `RENDER_ATTACHMENT` usage. */\n  getRenderTexture(): GPUTexture {\n    return this.device.createTexture({\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n  }\n\n  /** Return an invalid GPUTexture. */\n  getErrorTexture(): GPUTexture {\n    this.device.pushErrorScope('validation');\n    const texture = this.device.createTexture({\n      size: { width: 0, height: 0, depthOrArrayLayers: 0 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.SAMPLED,\n    });\n    this.device.popErrorScope();\n    return texture;\n  }\n\n  /** Return an invalid GPUTextureView (created from an invalid GPUTexture). */\n  getErrorTextureView(): GPUTextureView {\n    this.device.pushErrorScope('validation');\n    const view = this.getErrorTexture().createView();\n    this.device.popErrorScope();\n    return view;\n  }\n\n  /**\n   * Return an arbitrary object of the specified {@link BindableResource} type\n   * (e.g. `'errorBuf'`, `'nonFiltSamp'`, `sampledTexMS`, etc.)\n   */\n  getBindingResource(bindingType: BindableResource): GPUBindingResource {\n    switch (bindingType) {\n      case 'errorBuf':\n        return { buffer: this.getErrorBuffer() };\n      case 'errorSamp':\n        return this.getErrorSampler();\n      case 'errorTex':\n        return this.getErrorTextureView();\n      case 'uniformBuf':\n        return { buffer: this.getUniformBuffer() };\n      case 'storageBuf':\n        return { buffer: this.getStorageBuffer() };\n      case 'filtSamp':\n        return this.device.createSampler({ minFilter: 'linear' });\n      case 'nonFiltSamp':\n        return this.device.createSampler();\n      case 'compareSamp':\n        return this.device.createSampler({ compare: 'never' });\n      case 'sampledTex':\n        return this.getSampledTexture(1).createView();\n      case 'sampledTexMS':\n        return this.getSampledTexture(4).createView();\n      case 'storageTex':\n        return this.getStorageTexture().createView();\n    }\n  }\n\n  /** Create a GPURenderPipeline in the specified state. */\n  createRenderPipelineWithState(state: 'valid' | 'invalid'): GPURenderPipeline {\n    return state === 'valid' ? this.createNoOpRenderPipeline() : this.createErrorRenderPipeline();\n  }\n\n  /** Return a GPURenderPipeline with default options and no-op vertex and fragment shaders. */\n  createNoOpRenderPipeline(): GPURenderPipeline {\n    return this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `[[stage(vertex)]] fn main() -> [[builtin(position)]] vec4<f32> {\n  return vec4<f32>();\n}`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: '[[stage(fragment)]] fn main() {}',\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n  }\n\n  /** Return an invalid GPURenderPipeline. */\n  createErrorRenderPipeline(): GPURenderPipeline {\n    this.device.pushErrorScope('validation');\n    const pipeline = this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: '',\n        }),\n        entryPoint: '',\n      },\n    });\n    this.device.popErrorScope();\n    return pipeline;\n  }\n\n  /** Return a GPUComputePipeline with a no-op shader. */\n  createNoOpComputePipeline(): GPUComputePipeline {\n    return this.device.createComputePipeline({\n      compute: {\n        module: this.device.createShaderModule({\n          code: '[[stage(compute), workgroup_size(1)]] fn main() {}',\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  /** Return an invalid GPUComputePipeline. */\n  createErrorComputePipeline(): GPUComputePipeline {\n    this.device.pushErrorScope('validation');\n    const pipeline = this.device.createComputePipeline({\n      compute: {\n        module: this.device.createShaderModule({\n          code: '',\n        }),\n        entryPoint: '',\n      },\n    });\n    this.device.popErrorScope();\n    return pipeline;\n  }\n\n  /**\n   * Returns a GPUCommandEncoder, GPUComputePassEncoder, GPURenderPassEncoder, or\n   * GPURenderBundleEncoder, and a `finish` method returning a GPUCommandBuffer.\n   * Allows testing methods which have the same signature across multiple encoder interfaces.\n   *\n   * @example\n   * ```\n   * g.test('popDebugGroup')\n   *   .params(u => u.combine('encoderType', kEncoderTypes))\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     encoder.popDebugGroup();\n   *   });\n   *\n   * g.test('writeTimestamp')\n   *   .params(u => u.combine('encoderType', ['non-pass', 'compute pass', 'render pass'] as const)\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     // Encoder type is inferred, so `writeTimestamp` can be used even though it doesn't exist\n   *     // on GPURenderBundleEncoder.\n   *     encoder.writeTimestamp(args);\n   *   });\n   * ```\n   */\n  createEncoder<T extends EncoderType>(\n    encoderType: T,\n    {\n      attachmentInfo,\n      occlusionQuerySet,\n    }: {\n      attachmentInfo?: GPURenderBundleEncoderDescriptor;\n      occlusionQuerySet?: GPUQuerySet;\n    } = {}\n  ): CommandBufferMaker<T> {\n    const fullAttachmentInfo = {\n      // Defaults if not overridden:\n      colorFormats: ['rgba8unorm'],\n      sampleCount: 1,\n      // Passed values take precedent.\n      ...attachmentInfo,\n    } as const;\n\n    switch (encoderType) {\n      case 'non-pass': {\n        const encoder = this.device.createCommandEncoder();\n\n        return new CommandBufferMaker(this, encoder, (shouldSucceed: boolean) =>\n          this.expectGPUError('validation', () => encoder.finish(), !shouldSucceed)\n        );\n      }\n      case 'render bundle': {\n        const device = this.device;\n        const rbEncoder = device.createRenderBundleEncoder(fullAttachmentInfo);\n        const pass = this.createEncoder('render pass', { attachmentInfo });\n\n        return new CommandBufferMaker(this, rbEncoder, (shouldSucceed: boolean) => {\n          // If !shouldSucceed, the resulting bundle should be invalid.\n          const rb = this.expectGPUError('validation', () => rbEncoder.finish(), !shouldSucceed);\n          pass.encoder.executeBundles([rb]);\n          // Then, the pass should also be invalid if the bundle was invalid.\n          return pass.validateFinish(shouldSucceed);\n        });\n      }\n      case 'compute pass': {\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginComputePass();\n\n        return new CommandBufferMaker(this, encoder, (shouldSucceed: boolean) => {\n          encoder.endPass();\n          return this.expectGPUError('validation', () => commandEncoder.finish(), !shouldSucceed);\n        });\n      }\n      case 'render pass': {\n        const makeAttachmentView = (format: GPUTextureFormat) =>\n          this.device\n            .createTexture({\n              size: [16, 16, 1],\n              format,\n              usage: GPUTextureUsage.RENDER_ATTACHMENT,\n              sampleCount: fullAttachmentInfo.sampleCount,\n            })\n            .createView();\n\n        const passDesc: GPURenderPassDescriptor = {\n          colorAttachments: Array.from(fullAttachmentInfo.colorFormats, format => ({\n            view: makeAttachmentView(format),\n            loadValue: [0, 0, 0, 0],\n            storeOp: 'store',\n          })),\n          depthStencilAttachment:\n            fullAttachmentInfo.depthStencilFormat !== undefined\n              ? {\n                  view: makeAttachmentView(fullAttachmentInfo.depthStencilFormat),\n                  depthLoadValue: 0,\n                  depthStoreOp: 'discard',\n                  stencilLoadValue: 1,\n                  stencilStoreOp: 'discard',\n                }\n              : undefined,\n          occlusionQuerySet,\n        };\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginRenderPass(passDesc);\n        return new CommandBufferMaker(this, encoder, (shouldSucceed: boolean) => {\n          encoder.endPass();\n          return this.expectGPUError('validation', () => commandEncoder.finish(), !shouldSucceed);\n        });\n      }\n    }\n    unreachable();\n  }\n\n  /**\n   * Expect a validation error inside the callback.\n   *\n   * Tests should always do just one WebGPU call in the callback, to make sure that's what's tested.\n   */\n  expectValidationError(fn: () => void, shouldError: boolean = true): void {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (shouldError) {\n      this.device.pushErrorScope('validation');\n    }\n\n    // Note: A return value is not allowed for the callback function. This is to avoid confusion\n    // about what the actual behavior would be; either of the following could be reasonable:\n    //   - Make expectValidationError async, and have it await on fn(). This causes an async split\n    //     between pushErrorScope and popErrorScope, so if the caller doesn't `await` on\n    //     expectValidationError (either accidentally or because it doesn't care to do so), then\n    //     other test code will be (nondeterministically) caught by the error scope.\n    //   - Make expectValidationError NOT await fn(), but just execute its first block (until the\n    //     first await) and return the return value (a Promise). This would be confusing because it\n    //     would look like the error scope includes the whole async function, but doesn't.\n    // If we do decide we need to return a value, we should use the latter semantic.\n    const returnValue = fn() as unknown;\n    assert(\n      returnValue === undefined,\n      'expectValidationError callback should not return a value (or be async)'\n    );\n\n    if (shouldError) {\n      const promise = this.device.popErrorScope();\n\n      this.eventualAsyncExpectation(async niceStack => {\n        const gpuValidationError = await promise;\n        if (!gpuValidationError) {\n          niceStack.message = 'Validation succeeded unexpectedly.';\n          this.rec.validationFailed(niceStack);\n        } else if (gpuValidationError instanceof GPUValidationError) {\n          niceStack.message = `Validation failed, as expected - ${gpuValidationError.message}`;\n          this.rec.debug(niceStack);\n        }\n      });\n    }\n  }\n}\n"],"file":"validation_test.js"}