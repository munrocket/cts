{"version":3,"sources":["../../../../../src/webgpu/api/operation/vertex_state/correctness.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kPerStageBindingLimits","kVertexFormatInfo","kVertexFormats","GPUTest","float32ToFloat16Bits","normalizedIntegerAsFloat","align","clamp","mapBufferAttribs","buffer","f","newAttributes","a","attributes","push","shaderLocation","mapStateAttribs","buffers","map","b","VertexStateTest","makeTestWGSL","vertexCount","instanceCount","vsInputs","vsChecks","vsBindings","format","shaderComponentCount","componentCount","i","shaderType","shaderBaseType","maxCount","indexBuiltin","stepMode","component","expected","attribComponent","providedData","type","floatTolerance","makeTestPipeline","module","device","createShaderModule","code","bufferLayouts","slot","createRenderPipeline","vertex","entryPoint","primitive","topology","fragment","targets","submitRenderPass","pipeline","expectedData","testTexture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadValue","storeOp","setPipeline","setBindGroup","setVertexBuffer","vbOffset","draw","endPass","queue","submit","finish","expectSingleColor","exp","R","generateTestData","formatInfo","bitSize","bytesPerComponent","data","Float32Array","vertexData","Uint16Array","testComponentCount","length","Math","pow","Int32Array","Int16Array","Int8Array","Uint32Array","Uint8Array","v","expandTestData","vertexComponentSize","byteLength","expectedComponentSize","expandedVertexData","expandedExpectedData","index","targetVertexOffset","sourceVertexOffset","set","targetExpectedOffset","sourceExpectedOffset","interleaveVertexDataInto","target","source","targetStride","offset","t","sourceOffset","targetOffset","createTestAndPipelineData","state","attrib","testData","createExpectedBG","bgEntries","expectedDataBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","binding","resource","createBindGroup","layout","getBindGroupLayout","entries","createVertexBuffers","vertexBuffers","ArrayBuffer","arrayStride","fill","VERTEX","runTest","expectedDataBG","g","test","desc","params","u","combine","beginSubcases","fn","expand","p","componentSize","formatSize","Set","min","max","paramsSubcasesOnly","stepModes","vbCount","additionalVBOffset","kVertexCount","kInstanceCount","formatByteSize","alignedFormatByteSize","baseDataVertexCount","baseData","vertexBuffer","baseTestData","expectedDataBytesPerVertex","slice","attribs","maxTestableAttribs","attributesPerBuffer","ceil","attributesEmitted","j","kCount","stride0TestData","stride0VertexBuffer","originalData","expandedData","varyingTestData","varyingVertexBuffer"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA,CAHO,CAKP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,iCAApC;AACA;AACEC,oBADF;AAEEC,2BAFF;AAGEC,iBAHF;AAIEC,sBAJF;AAKEC,iBALF;AAMEC,cANF;AAOO,6BAPP;AAQA,SAASC,OAAT,QAAwB,sBAAxB;AACA,SAASC,oBAAT,EAA+BC,wBAA/B,QAA+D,6BAA/D;AACA,SAASC,KAAT,EAAgBC,KAAhB,QAA6B,uBAA7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA,SAASC,gBAAT;AACEC,MADF;AAEEC,CAFF;AAGuB;AACrB,QAAMC,aAAiC,GAAG,EAA1C;AACA,OAAK,MAAMC,CAAX,IAAgBH,MAAM,CAACI,UAAvB,EAAmC;AACjCF,IAAAA,aAAa,CAACG,IAAd,CAAmB;AACjBC,MAAAA,cAAc,EAAEH,CAAC,CAACG,cADD;AAEjB,SAAGL,CAAC,CAACD,MAAD,EAASG,CAAT,CAFa,EAAnB;;AAID;;AAED,SAAO,EAAE,GAAGH,MAAL,EAAaI,UAAU,EAAEF,aAAzB,EAAP;AACD;;AAED,SAASK,eAAT;AACEC,OADF;AAEEP,CAFF;AAGsB;AACpB,SAAOO,OAAO,CAACC,GAAR,CAAYC,CAAC,IAAIX,gBAAgB,CAACW,CAAD,EAAIT,CAAJ,CAAjC,CAAP;AACD;;;;;;;;;;;;;;AAcD,MAAMU,eAAN,SAA8BjB,OAA9B,CAAsC;AACpC;AACA;AACA;AACA;AACAkB,EAAAA,YAAY;AACVJ,EAAAA,OADU;;;;;;;;;AAUVK,EAAAA,WAVU;AAWVC,EAAAA,aAXU;AAYF;AACR,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,UAAU,GAAG,EAAjB;;AAEA,SAAK,MAAMP,CAAX,IAAgBF,OAAhB,EAAyB;AACvB,WAAK,MAAML,CAAX,IAAgBO,CAAC,CAACN,UAAlB,EAA8B;AAC5B,cAAMc,MAAM,GAAG1B,iBAAiB,CAACW,CAAC,CAACe,MAAH,CAAhC;AACA,cAAMC,oBAAoB,GAAGhB,CAAC,CAACgB,oBAAF,IAA0BD,MAAM,CAACE,cAA9D;AACA,cAAMC,CAAC,GAAGlB,CAAC,CAACG,cAAZ;;AAEA;AACA,YAAIgB,UAAU,GAAGnB,CAAC,CAACoB,cAAnB;AACA,YAAIJ,oBAAoB,KAAK,CAA7B,EAAgC;AAC9BG,UAAAA,UAAU,GAAI,MAAKH,oBAAqB,IAAGG,UAAW,GAAtD;AACD;;AAED,YAAIE,QAAQ,GAAI,GAAEX,WAAY,EAA9B;AACA,YAAIY,YAAY,GAAI,mBAApB;AACA,YAAIf,CAAC,CAACgB,QAAF,KAAe,UAAnB,EAA+B;AAC7BF,UAAAA,QAAQ,GAAI,GAAEV,aAAc,EAA5B;AACAW,UAAAA,YAAY,GAAI,qBAAhB;AACD;;AAEDV,QAAAA,QAAQ,IAAK,gBAAeM,CAAE,aAAYA,CAAE,MAAKC,UAAW,KAA5D;AACAL,QAAAA,UAAU,IAAK,qBAAoBI,CAAE,wBAAuBlB,CAAC,CAACoB,cAAe,MAAKC,QAAS,SAA3F;AACAP,QAAAA,UAAU,IAAK,uBAAsBI,CAAE,gCAA+BA,CAAE,OAAMA,CAAE,KAAhF;;AAEA;AACA,aAAK,IAAIM,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGR,oBAApC,EAA0DQ,SAAS,EAAnE,EAAuE;AACrE;AACA,cAAIA,SAAS,IAAIT,MAAM,CAACE,cAAxB,EAAwC;AACtC,kBAAMQ,QAAQ,GAAGD,SAAS,KAAK,CAAd,GAAkB,GAAlB,GAAwB,GAAzC;AACAX,YAAAA,QAAQ,IAAK,uBAAsBK,CAAE,IAAGM,SAAU,QAAOxB,CAAC,CAACoB,cAAe,IAAGK,QAAS,OAAtF;AACA;AACD;;AAED;AACA,gBAAMC,eAAe;AACnBV,UAAAA,oBAAoB,KAAK,CAAzB,GAA8B,eAAcE,CAAE,EAA9C,GAAmD,eAAcA,CAAE,IAAGM,SAAU,GADlF;AAEA,gBAAMG,YAAY,GAAI,eAAcT,CAAE,SAAQI,YAAa,KAAIE,SAAU,GAAzE;AACA,cAAIT,MAAM,CAACa,IAAP,KAAgB,MAAhB,IAA0Bb,MAAM,CAACa,IAAP,KAAgB,MAA9C,EAAsD;AACpDf,YAAAA,QAAQ,IAAK,WAAUa,eAAgB,OAAMC,YAAa,MAA1D;AACD,WAFD,MAEO;AACLd,YAAAA,QAAQ,IAAK,yBAAwBa,eAAgB,KAAIC,YAAa;AACpE3B,YAAAA,CAAC,CAAC6B,cAAF,IAAoB;AACrB,oBAFD;AAGD;AACF;AACF;AACF;;AAED,WAAQ;AACZ;AACA,EAAEjB,QAAS;AACX;AACA;AACA;AACA;AACA,EAAEE,UAAW;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAED,QAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwCH,WAAY;AACpD,0CAA0CC,aAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA9DI;AA+DD;;AAEDmB,EAAAA,gBAAgB;AACdzB,EAAAA,OADc;;;;;;;;;;AAWdK,EAAAA,WAXc;AAYdC,EAAAA,aAZc;AAaK;AACnB,UAAMoB,MAAM,GAAG,KAAKC,MAAL,CAAYC,kBAAZ,CAA+B;AAC5CC,MAAAA,IAAI,EAAE,KAAKzB,YAAL,CAAkBJ,OAAlB,EAA2BK,WAA3B,EAAwCC,aAAxC,CADsC,EAA/B,CAAf;;;AAIA,UAAMwB,aAAsC,GAAG,EAA/C;AACA,SAAK,MAAM5B,CAAX,IAAgBF,OAAhB,EAAyB;AACvB8B,MAAAA,aAAa,CAAC5B,CAAC,CAAC6B,IAAH,CAAb,GAAwB7B,CAAxB;AACD;;AAED,WAAO,KAAKyB,MAAL,CAAYK,oBAAZ,CAAiC;AACtCC,MAAAA,MAAM,EAAE;AACNP,QAAAA,MADM;AAENQ,QAAAA,UAAU,EAAE,QAFN;AAGNlC,QAAAA,OAAO,EAAE8B,aAHH,EAD8B;;AAMtCK,MAAAA,SAAS,EAAE;AACTC,QAAAA,QAAQ,EAAE,YADD,EAN2B;;AAStCC,MAAAA,QAAQ,EAAE;AACRX,QAAAA,MADQ;AAERQ,QAAAA,UAAU,EAAE,QAFJ;AAGRI,QAAAA,OAAO,EAAE;AACP;AACE5B,UAAAA,MAAM,EAAE,SADV,EADO,CAHD,EAT4B,EAAjC,CAAP;;;;;AAmBD;;AAED;AACA;AACA6B,EAAAA,gBAAgB;AACdC,EAAAA,QADc;AAEdxC,EAAAA,OAFc;AAGdyC,EAAAA,YAHc;AAIdpC,EAAAA,WAJc;AAKdC,EAAAA,aALc;AAMd;AACA,UAAMoC,WAAW,GAAG,KAAKf,MAAL,CAAYgB,aAAZ,CAA0B;AAC5CjC,MAAAA,MAAM,EAAE,SADoC;AAE5CkC,MAAAA,IAAI,EAAE,CAACvC,WAAD,EAAcC,aAAd,CAFsC;AAG5CuC,MAAAA,KAAK,EAAEC,eAAe,CAACC,iBAAhB,GAAoCD,eAAe,CAACE,QAHf,EAA1B,CAApB;;;AAMA,UAAMC,OAAO,GAAG,KAAKtB,MAAL,CAAYuB,oBAAZ,EAAhB;AACA,UAAMC,IAAI,GAAGF,OAAO,CAACG,eAAR,CAAwB;AACnCC,MAAAA,gBAAgB,EAAE;AAChB;AACEC,QAAAA,IAAI,EAAEZ,WAAW,CAACa,UAAZ,EADR;AAEEC,QAAAA,SAAS,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAFb;AAGEC,QAAAA,OAAO,EAAE,OAHX,EADgB,CADiB,EAAxB,CAAb;;;;;AAUAN,IAAAA,IAAI,CAACO,WAAL,CAAiBlB,QAAjB;AACAW,IAAAA,IAAI,CAACQ,YAAL,CAAkB,CAAlB,EAAqBlB,YAArB;AACA,SAAK,MAAMjD,MAAX,IAAqBQ,OAArB,EAA8B;AAC5BmD,MAAAA,IAAI,CAACS,eAAL,CAAqBpE,MAAM,CAACuC,IAA5B,EAAkCvC,MAAM,CAACA,MAAzC,EAAiDA,MAAM,CAACqE,QAAP,IAAmB,CAApE;AACD;AACDV,IAAAA,IAAI,CAACW,IAAL,CAAUzD,WAAV,EAAuBC,aAAvB;AACA6C,IAAAA,IAAI,CAACY,OAAL;;AAEA,SAAKpC,MAAL,CAAYqC,KAAZ,CAAkBC,MAAlB,CAAyB,CAAChB,OAAO,CAACiB,MAAR,EAAD,CAAzB;;AAEA,SAAKC,iBAAL,CAAuBzB,WAAvB,EAAoC,SAApC,EAA+C;AAC7CE,MAAAA,IAAI,EAAE,CAACvC,WAAD,EAAcC,aAAd,EAA6B,CAA7B,CADuC;AAE7C8D,MAAAA,GAAG,EAAE,EAAEC,CAAC,EAAE,CAAL,EAFwC,EAA/C;;AAID;;AAED;AACA;AACA;AACA;AACAC,EAAAA,gBAAgB,CAAC5D,MAAD,EAAoC;AAClD,UAAM6D,UAAU,GAAGvF,iBAAiB,CAAC0B,MAAD,CAApC;AACA,UAAM8D,OAAO,GAAGD,UAAU,CAACE,iBAAX,GAA+B,CAA/C;;AAEA,YAAQF,UAAU,CAAChD,IAAnB;AACE,WAAK,OAAL,CAAc;AACZ,gBAAMmD,IAAI,GAAG,CAAC,KAAD,EAAQ,GAAR,EAAa,GAAb,EAAkB,CAAC,GAAnB,EAAwB,IAAxB,EAA8B,CAAC,IAA/B,EAAqC,KAArC,CAAb;AACA,gBAAMjC,YAAY,GAAG,IAAIkC,YAAJ,CAAiBD,IAAjB,EAAuBlF,MAA5C;AACA,gBAAMoF,UAAU;AACdJ,UAAAA,OAAO,KAAK,EAAZ;AACI/B,UAAAA,YADJ;AAEI+B,UAAAA,OAAO,KAAK,EAAZ;AACA,cAAIK,WAAJ,CAAgBH,IAAI,CAACzE,GAAL,CAASd,oBAAT,CAAhB,EAAgDK,MADhD;AAEAb,UAAAA,WAAW,EALjB;;AAOA,iBAAO;AACLoC,YAAAA,cAAc,EAAE,KADX;AAEL+D,YAAAA,kBAAkB,EAAEJ,IAAI,CAACK,MAFpB;AAGLtC,YAAAA,YAHK;AAILmC,YAAAA,UAJK;AAKLpD,YAAAA,cAAc,EAAE,IALX,EAAP;;AAOD;;AAED,WAAK,MAAL,CAAa;;AAEX,gBAAMkD,IAAI,GAAG;AACX,YADW;AAEX,WAFW,EAER,CAFQ,EAEL,CAFK,EAEF,CAFE,EAEC,CAFD,EAEI,CAFJ;AAGX,WAAC,CAHU,EAGP,CAAC,CAHM,EAGH,CAAC,CAHE,EAGC,CAAC,CAHF,EAGK,CAAC,CAHN;AAIXM,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAO,GAAG,CAAtB,CAJW;AAKXQ,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAO,GAAG,CAAtB,IAA2B,CALhB,EAKmB;AAC9B,WAACQ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAO,GAAG,CAAtB,CANU;AAOX,WAACQ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAO,GAAG,CAAtB,CAPU,CAOgB;AAPhB,WAAb;AASA,gBAAM/B,YAAY,GAAG,IAAIyC,UAAJ,CAAeR,IAAf,EAAqBlF,MAA1C;AACA,gBAAMoF,UAAU;AACdJ,UAAAA,OAAO,KAAK,EAAZ;AACI/B,UAAAA,YADJ;AAEI+B,UAAAA,OAAO,KAAK,EAAZ;AACA,cAAIW,UAAJ,CAAeT,IAAf,EAAqBlF,MADrB;AAEA,cAAI4F,SAAJ,CAAcV,IAAd,EAAoBlF,MAL1B;;AAOA,iBAAO;AACLuB,YAAAA,cAAc,EAAE,KADX;AAEL+D,YAAAA,kBAAkB,EAAEJ,IAAI,CAACK,MAFpB;AAGLtC,YAAAA,YAHK;AAILmC,YAAAA,UAJK,EAAP;;AAMD;;AAED,WAAK,MAAL,CAAa;;AAEX,gBAAMF,IAAI,GAAG;AACX,YADW;AAEX,WAFW,EAER,CAFQ,EAEL,CAFK,EAEF,CAFE,EAEC,CAFD,EAEI,CAFJ;AAGXM,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAO,GAAG,CAAtB,CAHW;AAIXQ,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAZ,IAAuB,CAJZ,CAIe;AAJf,WAAb;AAMA,gBAAM/B,YAAY,GAAG,IAAI4C,WAAJ,CAAgBX,IAAhB,EAAsBlF,MAA3C;AACA,gBAAMoF,UAAU;AACdJ,UAAAA,OAAO,KAAK,EAAZ;AACI/B,UAAAA,YADJ;AAEI+B,UAAAA,OAAO,KAAK,EAAZ;AACA,cAAIK,WAAJ,CAAgBH,IAAhB,EAAsBlF,MADtB;AAEA,cAAI8F,UAAJ,CAAeZ,IAAf,EAAqBlF,MAL3B;;AAOA,iBAAO;AACLuB,YAAAA,cAAc,EAAE,KADX;AAEL+D,YAAAA,kBAAkB,EAAEJ,IAAI,CAACK,MAFpB;AAGLtC,YAAAA,YAHK;AAILmC,YAAAA,UAJK,EAAP;;AAMD;;AAED,WAAK,OAAL,CAAc;;AAEZ,gBAAMF,IAAI,GAAG;AACX,YADW;AAEX,WAFW,EAER,CAFQ,EAEL,CAFK,EAEF,CAFE,EAEC,CAFD,EAEI,CAFJ;AAGX,WAAC,CAHU,EAGP,CAAC,CAHM,EAGH,CAAC,CAHE,EAGC,CAAC,CAHF,EAGK,CAAC,CAHN;AAIXM,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAWT,OAAO,GAAG,CAArB,CAJW;AAKXQ,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAWT,OAAO,GAAG,CAArB,IAA0B,CALf,EAKkB;AAC7B,WAACQ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAWT,OAAO,GAAG,CAArB,CANU;AAOX,WAACQ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAWT,OAAO,GAAG,CAArB,CAPU,CAOe;AAPf,WAAb;AASA,gBAAMI,UAAU;AACdJ,UAAAA,OAAO,KAAK,EAAZ;AACI,cAAIW,UAAJ,CAAeT,IAAf,EAAqBlF,MADzB;AAEIgF,UAAAA,OAAO,KAAK,CAAZ;AACA,cAAIY,SAAJ,CAAcV,IAAd,EAAoBlF,MADpB;AAEAb,UAAAA,WAAW,EALjB;;AAOA,iBAAO;AACLoC,YAAAA,cAAc,EAAE,KADX;AAEL+D,YAAAA,kBAAkB,EAAEJ,IAAI,CAACK,MAFpB;AAGLtC,YAAAA,YAAY,EAAE,IAAIkC,YAAJ,CAAiBD,IAAI,CAACzE,GAAL,CAASsF,CAAC,IAAInG,wBAAwB,CAACmG,CAAD,EAAIf,OAAJ,EAAa,IAAb,CAAtC,CAAjB;AACXhF,YAAAA,MAJE;AAKLoF,YAAAA,UALK;AAMLpD,YAAAA,cAAc,EAAE,MAAMpC,wBAAwB,CAAC,CAAD,EAAIoF,OAAJ,EAAa,IAAb,CANzC,EAAP;;AAQD;;AAED,WAAK,OAAL,CAAc;;AAEZ,gBAAME,IAAI,GAAG;AACX,YADW;AAEX,WAFW,EAER,CAFQ,EAEL,CAFK,EAEF,CAFE,EAEC,CAFD,EAEI,CAFJ;AAGXM,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAO,GAAG,CAAtB,CAHW;AAIXQ,UAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,OAAZ,IAAuB,CAJZ,CAIe;AAJf,WAAb;AAMA,gBAAMI,UAAU;AACdJ,UAAAA,OAAO,KAAK,EAAZ;AACI,cAAIK,WAAJ,CAAgBH,IAAhB,EAAsBlF,MAD1B;AAEIgF,UAAAA,OAAO,KAAK,CAAZ;AACA,cAAIc,UAAJ,CAAeZ,IAAf,EAAqBlF,MADrB;AAEAb,UAAAA,WAAW,EALjB;;AAOA,iBAAO;AACLoC,YAAAA,cAAc,EAAE,KADX;AAEL+D,YAAAA,kBAAkB,EAAEJ,IAAI,CAACK,MAFpB;AAGLtC,YAAAA,YAAY,EAAE,IAAIkC,YAAJ,CAAiBD,IAAI,CAACzE,GAAL,CAASsF,CAAC,IAAInG,wBAAwB,CAACmG,CAAD,EAAIf,OAAJ,EAAa,KAAb,CAAtC,CAAjB;AACXhF,YAAAA,MAJE;AAKLoF,YAAAA,UAAU,EAAEA,UALP;AAMLpD,YAAAA,cAAc,EAAE,MAAMpC,wBAAwB,CAAC,CAAD,EAAIoF,OAAJ,EAAa,KAAb,CANzC,EAAP;;AAQD,SA1HH;;AA4HD;;AAED;AACA;AACA;AACA;AACAgB,EAAAA,cAAc,CAACd,IAAD,EAAiB1D,QAAjB,EAAmCJ,cAAnC,EAAqE;AACjF,UAAM6E,mBAAmB,GAAGf,IAAI,CAACE,UAAL,CAAgBc,UAAhB,GAA6BhB,IAAI,CAACI,kBAA9D;AACA,UAAMa,qBAAqB,GAAGjB,IAAI,CAACjC,YAAL,CAAkBiD,UAAlB,GAA+BhB,IAAI,CAACI,kBAAlE;;AAEA,UAAMc,kBAAkB,GAAG,IAAIN,UAAJ,CAAetE,QAAQ,GAAGJ,cAAX,GAA4B6E,mBAA3C,CAA3B;AACA,UAAMI,oBAAoB,GAAG,IAAIP,UAAJ,CAAe,IAAItE,QAAJ,GAAe2E,qBAA9B,CAA7B;;AAEA,SAAK,IAAIG,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG9E,QAA5B,EAAsC8E,KAAK,EAA3C,EAA+C;AAC7C,WAAK,IAAI3E,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGP,cAApC,EAAoDO,SAAS,EAA7D,EAAiE;AAC/D;AACA,cAAM4E,kBAAkB,GAAG,CAACD,KAAK,GAAGlF,cAAR,GAAyBO,SAA1B,IAAuCsE,mBAAlE;AACA,cAAMO,kBAAkB,GAAGD,kBAAkB,GAAGrB,IAAI,CAACE,UAAL,CAAgBc,UAAhE;AACAE,QAAAA,kBAAkB,CAACK,GAAnB;AACE,YAAIX,UAAJ,CAAeZ,IAAI,CAACE,UAApB,EAAgCoB,kBAAhC,EAAoDP,mBAApD,CADF;AAEEM,QAAAA,kBAFF;;;AAKA,cAAMG,oBAAoB,GAAG,CAACJ,KAAK,GAAG,CAAR,GAAY3E,SAAb,IAA0BwE,qBAAvD;AACA,cAAMQ,oBAAoB;AACvB,SAACL,KAAK,GAAGlF,cAAR,GAAyBO,SAA1B,IAAuCwE,qBAAxC;AACAjB,QAAAA,IAAI,CAACjC,YAAL,CAAkBiD,UAFpB;AAGAG,QAAAA,oBAAoB,CAACI,GAArB;AACE,YAAIX,UAAJ,CAAeZ,IAAI,CAACjC,YAApB,EAAkC0D,oBAAlC,EAAwDR,qBAAxD,CADF;AAEEO,QAAAA,oBAFF;;AAID;AACF;;AAED,WAAO;AACLnF,MAAAA,cAAc,EAAE2D,IAAI,CAAC3D,cADhB;AAEL+D,MAAAA,kBAAkB,EAAE9D,QAAQ,GAAGJ,cAF1B;AAGLY,MAAAA,cAAc,EAAEkD,IAAI,CAAClD,cAHhB;AAILiB,MAAAA,YAAY,EAAEoD,oBAAoB,CAACrG,MAJ9B;AAKLoF,MAAAA,UAAU,EAAEgB,kBAAkB,CAACpG,MAL1B,EAAP;;AAOD;;AAED;AACA;AACA4G,EAAAA,wBAAwB;AACtBC,EAAAA,MADsB;AAEtBC,EAAAA,MAFsB;AAGtB,IAAEC,YAAF,EAAgBC,MAAhB,EAAwB5D,IAAxB,EAHsB;AAItB;AACA,UAAM6D,CAAC,GAAG,IAAInB,UAAJ,CAAee,MAAf,CAAV;AACA;AACE,QAAIK,YAAY,GAAG,CAAnB,EAAsBC,YAAY,GAAGH,MADvC;AAEEE,IAAAA,YAAY,GAAGJ,MAAM,CAACZ,UAFxB;AAGEgB,IAAAA,YAAY,IAAI9D,IAAhB,EAAsB+D,YAAY,IAAIJ,YAHxC;AAIE;AACA,YAAM5G,CAAC,GAAG,IAAI2F,UAAJ,CAAegB,MAAf,EAAuBI,YAAvB,EAAqC9D,IAArC,CAAV;AACA6D,MAAAA,CAAC,CAACR,GAAF,CAAMtG,CAAN,EAASgH,YAAT;AACD;AACF;;AAEDC,EAAAA,yBAAyB;AACvBC,EAAAA,KADuB;AAEvBxG,EAAAA,WAFuB;AAGvBC,EAAAA,aAHuB;AAIa;AACpC;AACA,WAAOP,eAAe,CAAC8G,KAAD,EAAQ,CAACrH,MAAD,EAASsH,MAAT,KAAoB;AAChD,YAAM9F,QAAQ,GAAGxB,MAAM,CAAC0B,QAAP,KAAoB,UAApB,GAAiCZ,aAAjC,GAAiDD,WAAlE;AACA,YAAMkE,UAAU,GAAGvF,iBAAiB,CAAC8H,MAAM,CAACpG,MAAR,CAApC;;AAEA,UAAIqG,QAAQ,GAAG,KAAKzC,gBAAL,CAAsBwC,MAAM,CAACpG,MAA7B,CAAf;AACAqG,MAAAA,QAAQ,GAAG,KAAKvB,cAAL,CAAoBuB,QAApB,EAA8B/F,QAA9B,EAAwCuD,UAAU,CAAC3D,cAAnD,CAAX;;AAEA,aAAO;AACL,WAAGmG,QADE;AAEL,WAAGD,MAFE,EAAP;;AAID,KAXqB,CAAtB;AAYD;;AAEDE,EAAAA,gBAAgB,CAACH,KAAD,EAAmCrE,QAAnC,EAA8E;AAC5F;AACA,UAAMyE,SAA8B,GAAG,EAAvC;;AAEA,SAAK,MAAMzH,MAAX,IAAqBqH,KAArB,EAA4B;AAC1B,WAAK,MAAMC,MAAX,IAAqBtH,MAAM,CAACI,UAA5B,EAAwC;AACtC,cAAMsH,kBAAkB,GAAG,KAAKC,sBAAL;AACzB,YAAI7B,UAAJ,CAAewB,MAAM,CAACrE,YAAtB,CADyB;AAEzB2E,QAAAA,cAAc,CAACC,OAFU,CAA3B;;AAIAJ,QAAAA,SAAS,CAACpH,IAAV,CAAe;AACbyH,UAAAA,OAAO,EAAER,MAAM,CAAChH,cADH;AAEbyH,UAAAA,QAAQ,EAAE,EAAE/H,MAAM,EAAE0H,kBAAV,EAFG,EAAf;;AAID;AACF;;AAED,WAAO,KAAKvF,MAAL,CAAY6F,eAAZ,CAA4B;AACjCC,MAAAA,MAAM,EAAEjF,QAAQ,CAACkF,kBAAT,CAA4B,CAA5B,CADyB;AAEjCC,MAAAA,OAAO,EAAEV,SAFwB,EAA5B,CAAP;;AAID;;AAEDW,EAAAA,mBAAmB;AACjBf,EAAAA,KADiB;AAEjBxG,EAAAA,WAFiB;AAGjBC,EAAAA,aAHiB;AAI0C;AAC3D;AACA,UAAMuH,aAAwE,GAAG,EAAjF;;AAEA,SAAK,MAAMrI,MAAX,IAAqBqH,KAArB,EAA4B;AAC1B,YAAM7F,QAAQ,GAAGxB,MAAM,CAAC0B,QAAP,KAAoB,UAApB,GAAiCZ,aAAjC,GAAiDD,WAAlE;;AAEA;AACA;AACA,YAAMuE,UAAU,GAAG,IAAIkD,WAAJ;AACjBzI,MAAAA,KAAK,CAACG,MAAM,CAACuI,WAAP,GAAqB/G,QAArB,IAAiCxB,MAAM,CAACqE,QAAP,IAAmB,CAApD,CAAD,EAAyD,CAAzD,CADY,CAAnB;;AAGA,UAAIyB,UAAJ,CAAeV,UAAf,EAA2BoD,IAA3B,CAAgC,IAAhC;;AAEA,WAAK,MAAMlB,MAAX,IAAqBtH,MAAM,CAACI,UAA5B,EAAwC;AACtC,cAAM2E,UAAU,GAAGvF,iBAAiB,CAAC8H,MAAM,CAACpG,MAAR,CAApC;AACA,aAAK0F,wBAAL,CAA8BxB,UAA9B,EAA0CkC,MAAM,CAAClC,UAAjD,EAA6D;AAC3D2B,UAAAA,YAAY,EAAE/G,MAAM,CAACuI,WADsC;AAE3DvB,UAAAA,MAAM,EAAE,CAAChH,MAAM,CAACqE,QAAP,IAAmB,CAApB,IAAyBiD,MAAM,CAACN,MAFmB;AAG3D5D,UAAAA,IAAI,EAAE2B,UAAU,CAAC3D,cAAX,GAA4B2D,UAAU,CAACE,iBAHc,EAA7D;;AAKD;;AAEDoD,MAAAA,aAAa,CAAChI,IAAd,CAAmB;AACjBkC,QAAAA,IAAI,EAAEvC,MAAM,CAACuC,IADI;AAEjBvC,QAAAA,MAAM,EAAE,KAAK2H,sBAAL,CAA4B,IAAI7B,UAAJ,CAAeV,UAAf,CAA5B,EAAwDwC,cAAc,CAACa,MAAvE,CAFS;AAGjBpE,QAAAA,QAAQ,EAAErE,MAAM,CAACqE,QAHA;AAIjBjE,QAAAA,UAAU,EAAE,EAJK,EAAnB;;AAMD;;AAED,WAAOiI,aAAP;AACD;;AAEDK,EAAAA,OAAO;AACLlI,EAAAA,OADK;AAEL;AACA;AACAK,EAAAA,WAAmB,GAAG,EAJjB;AAKLC,EAAAA,aAAqB,GAAG,EALnB;AAML;AACA,UAAMyG,QAAQ,GAAG,KAAKH,yBAAL,CAA+B5G,OAA/B,EAAwCK,WAAxC,EAAqDC,aAArD,CAAjB;AACA,UAAMkC,QAAQ,GAAG,KAAKf,gBAAL,CAAsBsF,QAAtB,EAAgC1G,WAAhC,EAA6CC,aAA7C,CAAjB;AACA,UAAM6H,cAAc,GAAG,KAAKnB,gBAAL,CAAsBD,QAAtB,EAAgCvE,QAAhC,CAAvB;AACA,UAAMqF,aAAa,GAAG,KAAKD,mBAAL,CAAyBb,QAAzB,EAAmC1G,WAAnC,EAAgDC,aAAhD,CAAtB;AACA,SAAKiC,gBAAL,CAAsBC,QAAtB,EAAgCqF,aAAhC,EAA+CM,cAA/C,EAA+D9H,WAA/D,EAA4EC,aAA5E;AACD,GA1fmC;;;AA6ftC,OAAO,MAAM8H,CAAC,GAAG3J,aAAa,CAAC0B,eAAD,CAAvB;;AAEPiI,CAAC,CAACC,IAAF,CAAO,2CAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA,kBANA;;AAQGC,MARH,CAQU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqBxJ,cADrB;AAEGwJ,OAFH,CAEW,sBAFX,EAEmC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAFnC;AAGGC,aAHH;AAIGD,OAJH,CAIW,MAJX,EAImB,CAAC,CAAD,EAAI,CAAJ,EAAO3J,iBAAiB,GAAG,CAA3B,CAJnB;AAKG2J,OALH,CAKW,gBALX,EAK6B,CAAC,CAAD,EAAI,CAAJ,EAAO7J,oBAAoB,GAAG,CAA9B,CAL7B,CATJ;;AAgBG+J,EAhBH,CAgBMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,EAAUC,oBAAV,EAAgCoB,IAAhC,EAAsCjC,cAAtC,KAAyD2G,CAAC,CAAC8B,MAAjE;AACA9B,EAAAA,CAAC,CAACyB,OAAF,CAAU;AACR;AACEnG,IAAAA,IADF;AAEEgG,IAAAA,WAAW,EAAE,EAFf;AAGE7G,IAAAA,QAAQ,EAAE,QAHZ;AAIEtB,IAAAA,UAAU,EAAE;AACV;AACEE,MAAAA,cADF;AAEEY,MAAAA,MAFF;AAGE8F,MAAAA,MAAM,EAAE,CAHV;AAIE7F,MAAAA,oBAJF,EADU,CAJd,EADQ,CAAV;;;;;AAeD,CAjCH;;AAmCAyH,CAAC,CAACC,IAAF,CAAO,6CAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,qDALA;;AAOGC,MAPH,CAOU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqBxJ,cADrB;AAEGyJ,aAFH;AAGGD,OAHH,CAGW,UAHX,EAGuB,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,IAAZ,CAHvB;AAIGA,OAJH,CAIW,aAJX,EAI0B,CAAC,GAAD,CAJ1B;AAKGG,MALH,CAKU,QALV,EAKoBC,CAAC,IAAI;AACrB,QAAMtE,UAAU,GAAGvF,iBAAiB,CAAC6J,CAAC,CAACnI,MAAH,CAApC;AACA,QAAMoI,aAAa,GAAGvE,UAAU,CAACE,iBAAjC;AACA,QAAMsE,UAAU,GAAGD,aAAa,GAAGvE,UAAU,CAAC3D,cAA9C;AACA,SAAO;AACL,GADK;AAELkI,EAAAA,aAFK;AAGLA,EAAAA,aAAa,GAAG,CAHX;AAILA,EAAAA,aAAa,GAAG,CAJX;AAKLD,EAAAA,CAAC,CAACd,WAAF,GAAgB,CALX;AAMLc,EAAAA,CAAC,CAACd,WAAF,GAAgBgB,UAAhB,GAA6BD,aAAa,GAAG,CANxC;AAOLD,EAAAA,CAAC,CAACd,WAAF,GAAgBgB,UAAhB,GAA6BD,aAAa,GAAG,CAPxC;AAQLD,EAAAA,CAAC,CAACd,WAAF,GAAgBgB,UAAhB,GAA6BD,aARxB;AASLD,EAAAA,CAAC,CAACd,WAAF,GAAgBgB,UATX,CAAP;;AAWD,CApBH,CARJ;;AA8BGJ,EA9BH,CA8BMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,EAAUmD,QAAV,EAAoBkE,WAApB,EAAiCvB,MAAjC,KAA4CC,CAAC,CAAC8B,MAApD;AACA9B,EAAAA,CAAC,CAACyB,OAAF,CAAU;AACR;AACEnG,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAFF;AAGE7G,IAAAA,QAAQ,EAAE,QAHZ;AAIE2C,IAAAA,QAJF;AAKEjE,IAAAA,UAAU,EAAE;AACV;AACEE,MAAAA,cAAc,EAAE,CADlB;AAEEY,MAAAA,MAFF;AAGE8F,MAAAA,MAHF,EADU,CALd,EADQ,CAAV;;;;;AAeD,CA/CH;;AAiDA4B,CAAC,CAACC,IAAF,CAAO,4CAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,qDALA;;AAOGC,MAPH,CAOU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqBxJ,cADrB;AAEGyJ,aAFH;AAGGE,MAHH,CAGU,aAHV,EAGyBC,CAAC,IAAI;AAC1B,QAAMtE,UAAU,GAAGvF,iBAAiB,CAAC6J,CAAC,CAACnI,MAAH,CAApC;AACA,QAAMoI,aAAa,GAAGvE,UAAU,CAACE,iBAAjC;AACA,QAAMsE,UAAU,GAAGD,aAAa,GAAGvE,UAAU,CAAC3D,cAA9C;;AAEA,SAAO,CAACvB,KAAK,CAAC0J,UAAD,EAAa,CAAb,CAAN,EAAuB1J,KAAK,CAAC0J,UAAD,EAAa,CAAb,CAAL,GAAuB,CAA9C,EAAiDlK,2BAAjD,CAAP;AACD,CATH;AAUG+J,MAVH,CAUU,QAVV,EAUoBC,CAAC,IAAI;AACrB,QAAMtE,UAAU,GAAGvF,iBAAiB,CAAC6J,CAAC,CAACnI,MAAH,CAApC;AACA,QAAMoI,aAAa,GAAGvE,UAAU,CAACE,iBAAjC;AACA,QAAMsE,UAAU,GAAGD,aAAa,GAAGvE,UAAU,CAAC3D,cAA9C;AACA,SAAO,IAAIoI,GAAJ;AACL;AACE,GADF;AAEEF,EAAAA,aAFF;AAGED,EAAAA,CAAC,CAACd,WAAF,GAAgB,CAHlB;AAIEc,EAAAA,CAAC,CAACd,WAAF,GAAgBgB,UAAhB,GAA6BD,aAJ/B;AAKED,EAAAA,CAAC,CAACd,WAAF,GAAgBgB,UALlB;AAME9I,EAAAA,GANF,CAMMuG,MAAM,IAAIlH,KAAK,CAACkH,MAAD,EAAS,EAAEyC,GAAG,EAAE,CAAP,EAAUC,GAAG,EAAEL,CAAC,CAACd,WAAF,GAAgBgB,UAA/B,EAAT,CANrB,CADK,CAAP;;AASD,CAvBH,CARJ;;AAiCGJ,EAjCH,CAiCMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,EAAUqH,WAAV,EAAuBvB,MAAvB,KAAkCC,CAAC,CAAC8B,MAA1C;AACA9B,EAAAA,CAAC,CAACyB,OAAF,CAAU;AACR;AACEnG,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAFF;AAGE7G,IAAAA,QAAQ,EAAE,QAHZ;AAIEtB,IAAAA,UAAU,EAAE;AACV;AACEE,MAAAA,cAAc,EAAE,CADlB;AAEEY,MAAAA,MAFF;AAGE8F,MAAAA,MAHF,EADU,CAJd,EADQ,CAAV;;;;;AAcD,CAjDH;;AAmDA4B,CAAC,CAACC,IAAF,CAAO,gCAAP;AACGC,IADH;AAEK;AACL,sCAHA;;AAKGa,kBALH,CAKsB,CAAAX,CAAC;AACnBA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,WADX,EACwB;AACpB,CAAC,UAAD,CADoB;AAEpB,CAAC,QAAD,EAAW,QAAX,EAAqB,UAArB,CAFoB;AAGpB,CAAC,UAAD,EAAa,QAAb,EAAuB,UAAvB,CAHoB;AAIpB,CAAC,QAAD,EAAW,UAAX,EAAuB,QAAvB,EAAiC,QAAjC,CAJoB,CADxB,CANJ;;;AAcGE,EAdH,CAcMlC,CAAC,IAAI;AACP,QAAM,EAAE2C,SAAF,KAAgB3C,CAAC,CAAC8B,MAAxB;AACA,QAAM1B,KAAK,GAAIuC,SAAD,CAAkCnJ,GAAlC,CAAsC,CAACiB,QAAD,EAAWL,CAAX,MAAkB;AACpEkB,IAAAA,IAAI,EAAElB,CAD8D;AAEpEkH,IAAAA,WAAW,EAAE,CAFuD;AAGpE7G,IAAAA,QAHoE;AAIpEtB,IAAAA,UAAU,EAAE;AACV;AACEE,MAAAA,cAAc,EAAEe,CADlB;AAEEH,MAAAA,MAAM,EAAE,SAFV;AAGE8F,MAAAA,MAAM,EAAE,CAHV,EADU,CAJwD,EAAlB,CAAtC,CAAd;;;;AAYAC,EAAAA,CAAC,CAACyB,OAAF,CAAUrB,KAAV;AACD,CA7BH;;AA+BAuB,CAAC,CAACC,IAAF,CAAO,8CAAP;AACGC,IADH;AAEK;AACL;AACA,sDAJA;;AAMGC,MANH,CAMU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqBxJ,cADrB;AAEGyJ,aAFH;AAGGD,OAHH,CAGW,SAHX,EAGsB,CAAC,CAAD,EAAI,CAAJ,EAAO3J,iBAAP,CAHtB;AAIG2J,OAJH,CAIW,oBAJX,EAIiC,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,CAJjC,CAPJ;;AAaGE,EAbH,CAaMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,EAAU2I,OAAV,EAAmBC,kBAAnB,KAA0C7C,CAAC,CAAC8B,MAAlD;AACA,QAAMgB,YAAY,GAAG,EAArB;AACA,QAAMC,cAAc,GAAG,CAAvB;AACA,QAAMjF,UAAU,GAAGvF,iBAAiB,CAAC0B,MAAD,CAApC;AACA,QAAM+I,cAAc,GAAGlF,UAAU,CAACE,iBAAX,GAA+BF,UAAU,CAAC3D,cAAjE;AACA;AACA,QAAM8I,qBAAqB,GAAGrK,KAAK,CAACoK,cAAD,EAAiB,CAAjB,CAAnC;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAME,mBAAmB,GAAGJ,YAAY,GAAGF,OAAf,GAAyB,CAArD;AACA,QAAMO,QAAQ,GAAGnD,CAAC,CAACG,yBAAF;AACf;AACE;AACE7E,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAAW,EAAE2B,qBAFf;AAGExI,IAAAA,QAAQ,EAAE,QAHZ;AAIE2C,IAAAA,QAAQ,EAAEyF,kBAJZ;AAKE1J,IAAAA,UAAU,EAAE,CAAC,EAAEE,cAAc,EAAE,CAAlB,EAAqBY,MAArB,EAA6B8F,MAAM,EAAE,CAArC,EAAD,CALd,EADF,CADe;;;AAUfmD,EAAAA,mBAVe;AAWfH,EAAAA,cAXe,CAAjB;;AAaA,QAAMK,YAAY,GAAGpD,CAAC,CAACmB,mBAAF,CAAsBgC,QAAtB,EAAgCD,mBAAhC,EAAqDH,cAArD,EAAqE,CAArE;AAClBhK,EAAAA,MADH;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAMsK,YAAY,GAAGF,QAAQ,CAAC,CAAD,CAAR,CAAYhK,UAAZ,CAAuB,CAAvB,CAArB;AACAlB,EAAAA,MAAM,CAACoL,YAAY,CAAChF,kBAAb,KAAoCP,UAAU,CAAC3D,cAAX,GAA4B+I,mBAAjE,CAAN;AACA,QAAMI,0BAA0B,GAAGD,YAAY,CAACrH,YAAb,CAA0BiD,UAA1B,GAAuCiE,mBAA1E;;AAEA,QAAM5C,QAAyC,GAAG,EAAlD;AACA,QAAMc,aAAuE,GAAG,EAAhF;AACA,OAAK,IAAIhH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwI,OAApB,EAA6BxI,CAAC,EAA9B,EAAkC;AAChCgH,IAAAA,aAAa,CAAChI,IAAd,CAAmB;AACjBL,MAAAA,MAAM,EAAEqK,YADS;AAEjB9H,MAAAA,IAAI,EAAElB,CAFW;AAGjBgD,MAAAA,QAAQ,EAAEyF,kBAAkB,GAAGzI,CAAC,GAAG6I,qBAHlB;AAIjB9J,MAAAA,UAAU,EAAE,EAJK,EAAnB;;;AAOAmH,IAAAA,QAAQ,CAAClH,IAAT,CAAc;AACZkC,MAAAA,IAAI,EAAElB,CADM;AAEZkH,MAAAA,WAAW,EAAE2B,qBAFD;AAGZxI,MAAAA,QAAQ,EAAE,QAHE;AAIZtB,MAAAA,UAAU,EAAE;AACV;AACEE,QAAAA,cAAc,EAAEe,CADlB;AAEEH,QAAAA,MAFF;AAGE8F,QAAAA,MAAM,EAAE,CAHV;;AAKEzF,QAAAA,cAAc,EAAE+I,YAAY,CAAC/I,cAL/B;AAMES,QAAAA,cAAc,EAAEsI,YAAY,CAACtI,cAN/B;AAOE;AACAsD,QAAAA,kBAAkB,EAAEyE,YAAY,GAAGhF,UAAU,CAAC3D,cARhD;AASE6B,QAAAA,YAAY,EAAEqH,YAAY,CAACrH,YAAb,CAA0BuH,KAA1B;AACZD,QAAAA,0BAA0B,GAAGlJ,CADjB;AAEZkJ,QAAAA,0BAA0B,IAAIR,YAAY,GAAG1I,CAAnB,CAFd,CAThB;;AAaE+D,QAAAA,UAAU,EAAE,IAAIkD,WAAJ,CAAgB,CAAhB,CAbd,EADU,CAJA,EAAd;;;;AAsBD;;AAED;AACA,QAAMtF,QAAQ,GAAGiE,CAAC,CAAChF,gBAAF,CAAmBsF,QAAnB,EAA6BwC,YAA7B,EAA2CC,cAA3C,CAAjB;AACA,QAAMrB,cAAc,GAAG1B,CAAC,CAACO,gBAAF,CAAmBD,QAAnB,EAA6BvE,QAA7B,CAAvB;AACAiE,EAAAA,CAAC,CAAClE,gBAAF,CAAmBC,QAAnB,EAA6BqF,aAA7B,EAA4CM,cAA5C,EAA4DoB,YAA5D,EAA0EC,cAA1E;AACD,CAjGH;;AAmGApB,CAAC,CAACC,IAAF,CAAO,+CAAP;AACGC,IADH;AAEK;AACL;AACA,sDAJA;;AAMGC,MANH,CAMU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqBxJ,cADrB;AAEGyJ,aAFH;AAGGD,OAHH,CAGW,SAHX,EAGsB,CAAC,CAAD,EAAI,CAAJ,EAAO3J,iBAAP,CAHtB;AAIG2J,OAJH,CAIW,oBAJX,EAIiC,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,CAJjC,CAPJ;;AAaGE,EAbH,CAaMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,EAAU2I,OAAV,EAAmBC,kBAAnB,KAA0C7C,CAAC,CAAC8B,MAAlD;AACA,QAAMgB,YAAY,GAAG,EAArB;AACA,QAAMC,cAAc,GAAG,CAAvB;AACA,QAAMjF,UAAU,GAAGvF,iBAAiB,CAAC0B,MAAD,CAApC;AACA,QAAM+I,cAAc,GAAGlF,UAAU,CAACE,iBAAX,GAA+BF,UAAU,CAAC3D,cAAjE;AACA;AACA,QAAM8I,qBAAqB,GAAGrK,KAAK,CAACoK,cAAD,EAAiB,CAAjB,CAAnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAMQ,OAA6B,GAAG,EAAtC;AACA,OAAK,IAAIpJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwI,OAApB,EAA6BxI,CAAC,EAA9B,EAAkC;AAChCoJ,IAAAA,OAAO,CAACpK,IAAR,CAAa,EAAEa,MAAF,EAAU8F,MAAM,EAAE3F,CAAC,GAAG6I,qBAAtB,EAA6C5J,cAAc,EAAEe,CAA7D,EAAb;AACD;AACD,QAAM+I,QAAQ,GAAGnD,CAAC,CAACG,yBAAF;AACf;AACE;AACE7E,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAAW,EAAE2B,qBAAqB,GAAGL,OAFvC;AAGEnI,IAAAA,QAAQ,EAAE,QAHZ;AAIE2C,IAAAA,QAAQ,EAAEyF,kBAJZ;AAKE1J,IAAAA,UAAU,EAAEqK,OALd,EADF,CADe;;;AAUfV,EAAAA,YAVe;AAWfC,EAAAA,cAXe,CAAjB;;AAaA,QAAMK,YAAY,GAAGpD,CAAC,CAACmB,mBAAF,CAAsBgC,QAAtB,EAAgCL,YAAhC,EAA8CC,cAA9C,EAA8D,CAA9D,EAAiEhK,MAAtF;;AAEA;AACA;AACA;AACA;AACA,QAAMuH,QAAyC,GAAG,EAAlD;AACA,QAAMc,aAAuE,GAAG,EAAhF;AACA,OAAK,IAAIhH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwI,OAApB,EAA6BxI,CAAC,EAA9B,EAAkC;AAChCgH,IAAAA,aAAa,CAAChI,IAAd,CAAmB;AACjBkC,MAAAA,IAAI,EAAElB,CADW;AAEjBrB,MAAAA,MAAM,EAAEqK,YAFS;AAGjBhG,MAAAA,QAAQ,EAAEyF,kBAAkB,GAAGzI,CAAC,GAAG6I,qBAHlB;AAIjB9J,MAAAA,UAAU,EAAE,EAJK,EAAnB;;AAMAmH,IAAAA,QAAQ,CAAClH,IAAT,CAAc;AACZ,SAAG+J,QAAQ,CAAC,CAAD,CADC;AAEZ7H,MAAAA,IAAI,EAAElB,CAFM;AAGZjB,MAAAA,UAAU,EAAE,CAAC,EAAE,GAAGgK,QAAQ,CAAC,CAAD,CAAR,CAAYhK,UAAZ,CAAuBiB,CAAvB,CAAL,EAAgC2F,MAAM,EAAE,CAAxC,EAAD,CAHA,EAAd;;AAKD;;AAED;AACA,QAAMhE,QAAQ,GAAGiE,CAAC,CAAChF,gBAAF,CAAmBsF,QAAnB,EAA6BwC,YAA7B,EAA2CC,cAA3C,CAAjB;AACA,QAAMrB,cAAc,GAAG1B,CAAC,CAACO,gBAAF,CAAmBD,QAAnB,EAA6BvE,QAA7B,CAAvB;AACAiE,EAAAA,CAAC,CAAClE,gBAAF,CAAmBC,QAAnB,EAA6BqF,aAA7B,EAA4CM,cAA5C,EAA4DoB,YAA5D,EAA0EC,cAA1E;AACD,CAzEH;;AA2EApB,CAAC,CAACC,IAAF,CAAO,yBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,GALA;;AAOGa,kBAPH,CAOsBX,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,QAAV,EAAoBxJ,cAApB,CAP3B;AAQG0J,EARH,CAQMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,KAAa+F,CAAC,CAAC8B,MAArB;AACA;AACA;AACA,QAAM2B,kBAAkB,GAAGlF,IAAI,CAACiE,GAAL;AACzBrK,EAAAA,oBADyB;AAEzBG,EAAAA,sBAAsB,CAAC,YAAD,CAAtB,CAAqCmK,GAFZ,CAA3B;;;AAKA,QAAMiB,mBAAmB,GAAGnF,IAAI,CAACoF,IAAL,CAAUF,kBAAkB,GAAGpL,iBAA/B,CAA5B;AACA,MAAIuL,iBAAiB,GAAG,CAAxB;;AAEA,QAAMxD,KAAgC,GAAG,EAAzC;AACA,OAAK,IAAIhG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,iBAApB,EAAuC+B,CAAC,EAAxC,EAA4C;AAC1C,UAAMjB,UAAgC,GAAG,EAAzC;AACA,SAAK,IAAI0K,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,mBAAJ,IAA2BE,iBAAiB,GAAGH,kBAA/D,EAAmFI,CAAC,EAApF,EAAwF;AACtF1K,MAAAA,UAAU,CAACC,IAAX,CAAgB,EAAEa,MAAF,EAAU8F,MAAM,EAAE,CAAlB,EAAqB1G,cAAc,EAAEuK,iBAArC,EAAhB;AACAA,MAAAA,iBAAiB;AAClB;AACDxD,IAAAA,KAAK,CAAChH,IAAN,CAAW;AACTkC,MAAAA,IAAI,EAAElB,CADG;AAETK,MAAAA,QAAQ,EAAE,QAFD;AAGT6G,MAAAA,WAAW,EAAE,EAHJ;AAITnI,MAAAA,UAJS,EAAX;;AAMD;AACD6G,EAAAA,CAAC,CAACyB,OAAF,CAAUrB,KAAV;AACD,CAnCH;;AAqCAuB,CAAC,CAACC,IAAF,CAAO,mBAAP;AACGC,IADH;AAEK;AACL;AACA,6BAJA;;AAMGC,MANH,CAMU,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqBxJ,cADrB;AAEGyJ,aAFH;AAGGD,OAHH,CAGW,UAHX,EAGuB,CAAC,QAAD,EAAW,UAAX,CAHvB;AAIGG,MAJH,CAIU,QAJV,EAIoBC,CAAC,IAAI;AACrB,QAAMtE,UAAU,GAAGvF,iBAAiB,CAAC6J,CAAC,CAACnI,MAAH,CAApC;AACA,QAAMoI,aAAa,GAAGvE,UAAU,CAACE,iBAAjC;AACA,QAAMsE,UAAU,GAAGD,aAAa,GAAGvE,UAAU,CAAC3D,cAA9C;AACA,SAAO,IAAIoI,GAAJ,CAAQ;AACb,GADa;AAEbF,EAAAA,aAFa;AAGbA,EAAAA,aAAa,GAAG,CAHH;AAIbA,EAAAA,aAAa,GAAG,CAJH;AAKbjK,EAAAA,2BAA2B,GAAG,CALjB;AAMbA,EAAAA,2BAA2B,GAAGkK,UAA9B,GAA2CD,aAAa,GAAG,CAN9C;AAObjK,EAAAA,2BAA2B,GAAGkK,UAA9B,GAA2CD,aAAa,GAAG,CAP9C;AAQbjK,EAAAA,2BAA2B,GAAGkK,UAA9B,GAA2CD,aAR9B;AASbjK,EAAAA,2BAA2B,GAAGkK,UATjB,CAAR,CAAP;;AAWD,CAnBH,CAPJ;;AA4BGJ,EA5BH,CA4BMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,EAAUQ,QAAV,EAAoBsF,MAApB,KAA+BC,CAAC,CAAC8B,MAAvC;AACA,QAAMgC,MAAM,GAAG,EAAf;;AAEA;AACA;AACA,QAAMC,eAAe,GAAG/D,CAAC,CAACG,yBAAF;AACtB;AACE;AACE7E,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAAW,EAAE,IAFf;AAGE7G,IAAAA,QAHF;AAIE2C,IAAAA,QAAQ,EAAE2C,MAJZ,EAIoB;AAClB5G,IAAAA,UAAU,EAAE,CAAC,EAAEc,MAAF,EAAU8F,MAAM,EAAE,CAAlB,EAAqB1G,cAAc,EAAE,CAArC,EAAD,CALd,EADF,CADsB;;;AAUtB,GAVsB;AAWtB,GAXsB;AAYtB,GAZsB,CAAxB;AAaA,QAAM2K,mBAAmB,GAAGhE,CAAC,CAACmB,mBAAF,CAAsB,CAAC4C,eAAD,CAAtB,EAAyCD,MAAzC,EAAiDA,MAAjD,EAAyD,CAAzD,CAA5B;;AAEA;AACA,QAAMG,YAAY,GAAGF,eAAe,CAAC5K,UAAhB,CAA2B,CAA3B,EAA8B6C,YAAnD;AACA,QAAMkI,YAAY,GAAG,IAAI7C,WAAJ,CAAgByC,MAAM,GAAGG,YAAY,CAAChF,UAAtC,CAArB;AACA,OAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0J,MAApB,EAA4B1J,CAAC,EAA7B,EAAiC;AAC/B,QAAIyE,UAAJ,CAAeqF,YAAf,EAA6BD,YAAY,CAAChF,UAAb,GAA0B7E,CAAvD,EAA0DoF,GAA1D,CAA8D,IAAIX,UAAJ,CAAeoF,YAAf,CAA9D;AACD;;AAED;AACAF,EAAAA,eAAe,CAAC5K,UAAhB,CAA2B,CAA3B,EAA8B4G,MAA9B,GAAuCA,MAAvC;AACAgE,EAAAA,eAAe,CAAC5K,UAAhB,CAA2B,CAA3B,EAA8B6C,YAA9B,GAA6CkI,YAA7C;AACAH,EAAAA,eAAe,CAAC5K,UAAhB,CAA2B,CAA3B,EAA8BkF,kBAA9B,IAAoDyF,MAApD;AACAC,EAAAA,eAAe,CAACzC,WAAhB,GAA8B,CAA9B;AACA0C,EAAAA,mBAAmB,CAAC5G,QAApB,GAA+B,CAA/B;;AAEA;AACA,QAAM+G,eAAe,GAAGnE,CAAC,CAACG,yBAAF;AACtB;AACE;AACE7E,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAAW,EAAE,EAFf;AAGE7G,IAAAA,QAHF;AAIEtB,IAAAA,UAAU,EAAE,CAAC,EAAEc,MAAF,EAAU8F,MAAM,EAAE,CAAlB,EAAqB1G,cAAc,EAAE,CAArC,EAAD,CAJd,EADF,CADsB;;;AAStByK,EAAAA,MATsB;AAUtBA,EAAAA,MAVsB;AAWtB,GAXsB,CAAxB;AAYA,QAAMM,mBAAmB,GAAGpE,CAAC,CAACmB,mBAAF,CAAsB,CAACgD,eAAD,CAAtB,EAAyCL,MAAzC,EAAiDA,MAAjD,EAAyD,CAAzD,CAA5B;;AAEA;AACA,QAAM1D,KAAK,GAAG,CAAC2D,eAAD,EAAkBI,eAAlB,CAAd;AACA,QAAM/C,aAAa,GAAG,CAAC4C,mBAAD,EAAsBI,mBAAtB,CAAtB;;AAEA,QAAMrI,QAAQ,GAAGiE,CAAC,CAAChF,gBAAF,CAAmBoF,KAAnB,EAA0B0D,MAA1B,EAAkCA,MAAlC,CAAjB;AACA,QAAMpC,cAAc,GAAG1B,CAAC,CAACO,gBAAF,CAAmBH,KAAnB,EAA0BrE,QAA1B,CAAvB;AACAiE,EAAAA,CAAC,CAAClE,gBAAF,CAAmBC,QAAnB,EAA6BqF,aAA7B,EAA4CM,cAA5C,EAA4DoC,MAA5D,EAAoEA,MAApE;AACD,CArFH;;AAuFAnC,CAAC,CAACC,IAAF,CAAO,oCAAP;AACGC,IADH,CACQ,oEADR;AAEGK,EAFH,CAEMlC,CAAC,IAAI;AACPA,EAAAA,CAAC,CAACyB,OAAF,CAAU;AACR;AACEnG,IAAAA,IAAI,EAAEjD,iBAAiB,GAAG,CAD5B;AAEEiJ,IAAAA,WAAW,EAAE,CAFf;AAGE7G,IAAAA,QAAQ,EAAE,QAHZ;AAIEtB,IAAAA,UAAU,EAAE;AACV,MAAEc,MAAM,EAAE,SAAV,EAAqB8F,MAAM,EAAE,CAA7B,EAAgC1G,cAAc,EAAE,CAAhD,EADU;AAEV,MAAEY,MAAM,EAAE,SAAV,EAAqB8F,MAAM,EAAE,CAA7B,EAAgC1G,cAAc,EAAE,CAAhD,EAFU,CAJd,EADQ;;;AAUR;AACEiC,IAAAA,IAAI,EAAE,CADR;AAEEgG,IAAAA,WAAW,EAAE,EAFf;AAGE7G,IAAAA,QAAQ,EAAE,UAHZ;AAIE2C,IAAAA,QAAQ,EAAE,IAJZ;AAKEjE,IAAAA,UAAU,EAAE,CAAC,EAAEc,MAAM,EAAE,UAAV,EAAsB8F,MAAM,EAAE,CAA9B,EAAiC1G,cAAc,EAAElB,oBAAoB,GAAG,CAAxE,EAAD,CALd,EAVQ,CAAV;;;AAkBD,CArBH;;AAuBAwJ,CAAC,CAACC,IAAF,CAAO,wBAAP;AACGC,IADH;AAEK;AACL;AACA,iGAJA;;AAMGa,kBANH,CAMsBX,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,QAAV,EAAoBxJ,cAApB,CAN3B;AAOG0J,EAPH,CAOMlC,CAAC,IAAI;AACP,QAAM,EAAE/F,MAAF,KAAa+F,CAAC,CAAC8B,MAArB;AACA;AACA;AACA,QAAM2B,kBAAkB,GAAGlF,IAAI,CAACiE,GAAL;AACzBrK,EAAAA,oBADyB;AAEzBG,EAAAA,sBAAsB,CAAC,YAAD,CAAtB,CAAqCmK,GAFZ,CAA3B;;;AAKA,QAAMtJ,UAAgC,GAAG,EAAzC;AACA,OAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqJ,kBAApB,EAAwCrJ,CAAC,EAAzC,EAA6C;AAC3CjB,IAAAA,UAAU,CAACC,IAAX,CAAgB,EAAEa,MAAF,EAAU8F,MAAM,EAAE,CAAlB,EAAqB1G,cAAc,EAAEe,CAArC,EAAhB;AACD;;AAED4F,EAAAA,CAAC,CAACyB,OAAF,CAAU;AACR;AACEnG,IAAAA,IAAI,EAAE,CADR;AAEEb,IAAAA,QAAQ,EAAE,QAFZ;AAGE6G,IAAAA,WAAW,EAAE,EAHf;AAIEnI,IAAAA,UAJF,EADQ,CAAV;;;AAQD,CA7BH","sourcesContent":["export const description = `\nTODO: Test more corner case values for Float16 / Float32 (INF, NaN, +-0, ...) and reduce the\nfloat tolerance.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kPerStageBindingLimits,\n  kVertexFormatInfo,\n  kVertexFormats,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { float32ToFloat16Bits, normalizedIntegerAsFloat } from '../../../util/conversion.js';\nimport { align, clamp } from '../../../util/math.js';\n\n// These types mirror the structure of GPUVertexBufferLayout but allow defining the extra\n// dictionary members at the GPUVertexBufferLayout and GPUVertexAttribute level. The are used\n// like so:\n//\n//   VertexState<{arrayStride: number}, {format: VertexFormat}>\n//   VertexBuffer<{arrayStride: number}, {format: VertexFormat}>\n//   VertexAttrib<{format: VertexFormat}>\ntype VertexAttrib<A> = A & { shaderLocation: number };\ntype VertexBuffer<V, A> = V & {\n  slot: number;\n  attributes: VertexAttrib<A>[];\n};\ntype VertexState<V, A> = VertexBuffer<V, A>[];\n\ntype VertexLayoutState<V, A> = VertexState<\n  { stepMode: GPUInputStepMode; arrayStride: number } & V,\n  { format: GPUVertexFormat; offset: number } & A\n>;\n\nfunction mapBufferAttribs<V, A1, A2>(\n  buffer: VertexBuffer<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexBuffer<V, A2> {\n  const newAttributes: VertexAttrib<A2>[] = [];\n  for (const a of buffer.attributes) {\n    newAttributes.push({\n      shaderLocation: a.shaderLocation,\n      ...f(buffer, a),\n    });\n  }\n\n  return { ...buffer, attributes: newAttributes };\n}\n\nfunction mapStateAttribs<V, A1, A2>(\n  buffers: VertexState<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexState<V, A2> {\n  return buffers.map(b => mapBufferAttribs(b, f));\n}\n\ntype TestData = {\n  shaderBaseType: string;\n  floatTolerance?: number;\n  // The number of vertex components in the vertexData (expectedData might contain more because\n  // it is padded to 4 components).\n  testComponentCount: number;\n  // The data that will be in the uniform buffer and used to check the vertex inputs.\n  expectedData: ArrayBuffer;\n  // The data that will be in the vertex buffer.\n  vertexData: ArrayBuffer;\n};\n\nclass VertexStateTest extends GPUTest {\n  // Generate for VS + FS (entrypoints vsMain / fsMain) that for each attribute will check that its\n  // value corresponds to what's expected (as provided by a uniform buffer per attribute) and then\n  // renders each vertex at position (vertexIndex, instanceindex) with either 1 (success) or\n  // a negative number corresponding to the check number (in case you need to debug a failure).\n  makeTestWGSL(\n    buffers: VertexState<\n      { stepMode: GPUInputStepMode },\n      {\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): string {\n    let vsInputs = '';\n    let vsChecks = '';\n    let vsBindings = '';\n\n    for (const b of buffers) {\n      for (const a of b.attributes) {\n        const format = kVertexFormatInfo[a.format];\n        const shaderComponentCount = a.shaderComponentCount ?? format.componentCount;\n        const i = a.shaderLocation;\n\n        // shaderType is either a scalar type like f32 or a vecN<scalarType>\n        let shaderType = a.shaderBaseType;\n        if (shaderComponentCount !== 1) {\n          shaderType = `vec${shaderComponentCount}<${shaderType}>`;\n        }\n\n        let maxCount = `${vertexCount}`;\n        let indexBuiltin = `input.vertexIndex`;\n        if (b.stepMode === 'instance') {\n          maxCount = `${instanceCount}`;\n          indexBuiltin = `input.instanceIndex`;\n        }\n\n        vsInputs += `  [[location(${i})]] attrib${i} : ${shaderType};\\n`;\n        vsBindings += `[[block]] struct S${i} { data : array<vec4<${a.shaderBaseType}>, ${maxCount}>; };\\n`;\n        vsBindings += `[[group(0), binding(${i})]] var<uniform> providedData${i} : S${i};\\n`;\n\n        // Generate the all the checks for the attributes.\n        for (let component = 0; component < shaderComponentCount; component++) {\n          // Components are filled with (0, 0, 0, 1) if they aren't provided data from the pipeline.\n          if (component >= format.componentCount) {\n            const expected = component === 3 ? '1' : '0';\n            vsChecks += `  check(input.attrib${i}[${component}] == ${a.shaderBaseType}(${expected}));\\n`;\n            continue;\n          }\n\n          // Check each component individually, with special handling of tolerance for floats.\n          const attribComponent =\n            shaderComponentCount === 1 ? `input.attrib${i}` : `input.attrib${i}[${component}]`;\n          const providedData = `providedData${i}.data[${indexBuiltin}][${component}]`;\n          if (format.type === 'uint' || format.type === 'sint') {\n            vsChecks += `  check(${attribComponent} == ${providedData});\\n`;\n          } else {\n            vsChecks += `  check(floatsSimilar(${attribComponent}, ${providedData}, f32(${\n              a.floatTolerance ?? 0\n            })));\\n`;\n          }\n        }\n      }\n    }\n\n    return `\nstruct Inputs {\n${vsInputs}\n  [[builtin(vertex_index)]] vertexIndex: u32;\n  [[builtin(instance_index)]] instanceIndex: u32;\n};\n\n${vsBindings}\n\nvar<private> vsResult : i32 = 1;\nvar<private> checkIndex : i32 = 0;\nfn check(success : bool) {\n  if (!success) {\n    vsResult = -checkIndex;\n  }\n  checkIndex = checkIndex + 1;\n}\n\nfn floatsSimilar(a : f32, b : f32, tolerance : f32) -> bool {\n  if (isNan(a) && isNan(b)) {\n    return true;\n  }\n\n  if (isInf(a) && isInf(b) && sign(a) == sign(b)) {\n    return true;\n  }\n\n  if (isInf(a) || isInf(b)) {\n    return false;\n  }\n\n  // TODO do we check for + and - 0?\n  return abs(a - b) < tolerance;\n}\n\nfn doTest(input : Inputs) {\n${vsChecks}\n}\n\nstruct VSOutputs {\n  [[location(0)]] result : i32;\n  [[builtin(position)]] position : vec4<f32>;\n};\n\n[[stage(vertex)]] fn vsMain(input : Inputs) -> VSOutputs {\n  doTest(input);\n\n  // Place that point at pixel (vertexIndex, instanceIndex) in a framebuffer of size\n  // (vertexCount , instanceCount).\n  var output : VSOutputs;\n  output.position = vec4<f32>(\n    ((f32(input.vertexIndex) + 0.5) / ${vertexCount}.0 * 2.0) - 1.0,\n    ((f32(input.instanceIndex) + 0.5) / ${instanceCount}.0 * 2.0) - 1.0,\n    0.0, 1.0\n  );\n  output.result = vsResult;\n  return output;\n}\n\n[[stage(fragment)]] fn fsMain([[location(0)]] result : i32) -> [[location(0)]] i32 {\n  return result;\n}\n    `;\n  }\n\n  makeTestPipeline(\n    buffers: VertexState<\n      { stepMode: GPUInputStepMode; arrayStride: number },\n      {\n        offset: number;\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): GPURenderPipeline {\n    const module = this.device.createShaderModule({\n      code: this.makeTestWGSL(buffers, vertexCount, instanceCount),\n    });\n\n    const bufferLayouts: GPUVertexBufferLayout[] = [];\n    for (const b of buffers) {\n      bufferLayouts[b.slot] = b;\n    }\n\n    return this.device.createRenderPipeline({\n      vertex: {\n        module,\n        entryPoint: 'vsMain',\n        buffers: bufferLayouts,\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fsMain',\n        targets: [\n          {\n            format: 'r32sint',\n          },\n        ],\n      },\n    });\n  }\n\n  // Runs the render pass drawing points in a vertexCount*instanceCount rectangle, then check each\n  // of produced a value of 1 which means that the tests in the shader passed.\n  submitRenderPass(\n    pipeline: GPURenderPipeline,\n    buffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}>,\n    expectedData: GPUBindGroup,\n    vertexCount: number,\n    instanceCount: number\n  ) {\n    const testTexture = this.device.createTexture({\n      format: 'r32sint',\n      size: [vertexCount, instanceCount],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: testTexture.createView(),\n          loadValue: [0, 0, 0, 0],\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, expectedData);\n    for (const buffer of buffers) {\n      pass.setVertexBuffer(buffer.slot, buffer.buffer, buffer.vbOffset ?? 0);\n    }\n    pass.draw(vertexCount, instanceCount);\n    pass.endPass();\n\n    this.device.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(testTexture, 'r32sint', {\n      size: [vertexCount, instanceCount, 1],\n      exp: { R: 1 },\n    });\n  }\n\n  // Generate TestData for the format with interesting test values.\n  // TODO cache the result on the fixture?\n  // Note that the test data always starts with an interesting value, so that using the first\n  // test value in a test is still meaningful.\n  generateTestData(format: GPUVertexFormat): TestData {\n    const formatInfo = kVertexFormatInfo[format];\n    const bitSize = formatInfo.bytesPerComponent * 8;\n\n    switch (formatInfo.type) {\n      case 'float': {\n        const data = [42.42, 0.0, 1.0, -1.0, 1000, -18.7, 25.17];\n        const expectedData = new Float32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data.map(float32ToFloat16Bits)).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n          floatTolerance: 0.05,\n        };\n      }\n\n      case 'sint': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2, bitSize - 2),\n          Math.pow(2, bitSize - 1) - 1, // max value\n          -Math.pow(2, bitSize - 2),\n          -Math.pow(2, bitSize - 1), // min value\n        ];\n        const expectedData = new Int32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Int16Array(data).buffer\n            : new Int8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'i32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'uint': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const expectedData = new Uint32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data).buffer\n            : new Uint8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'u32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'snorm': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2,bitSize - 2),\n          Math.pow(2,bitSize - 1) - 1, // max value\n          -Math.pow(2,bitSize - 2),\n          -Math.pow(2,bitSize - 1), // min value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Int16Array(data).buffer\n            : bitSize === 8\n            ? new Int8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, true)))\n            .buffer,\n          vertexData,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, true),\n        };\n      }\n\n      case 'unorm': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Uint16Array(data).buffer\n            : bitSize === 8\n            ? new Uint8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, false)))\n            .buffer,\n          vertexData: vertexData!,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, false),\n        };\n      }\n    }\n  }\n\n  // The TestData generated for a format might not contain enough data for all the vertices we are\n  // going to draw, so we expand them by adding additional copies of the vertexData as needed.\n  // expectedData is a bit different because it also needs to be unpacked to have `componentCount`\n  // components every 4 components (because the shader uses vec4 for the expected data).\n  expandTestData(data: TestData, maxCount: number, componentCount: number): TestData {\n    const vertexComponentSize = data.vertexData.byteLength / data.testComponentCount;\n    const expectedComponentSize = data.expectedData.byteLength / data.testComponentCount;\n\n    const expandedVertexData = new Uint8Array(maxCount * componentCount * vertexComponentSize);\n    const expandedExpectedData = new Uint8Array(4 * maxCount * expectedComponentSize);\n\n    for (let index = 0; index < maxCount; index++) {\n      for (let component = 0; component < componentCount; component++) {\n        // If only we had some builtin JS memcpy function between ArrayBuffers...\n        const targetVertexOffset = (index * componentCount + component) * vertexComponentSize;\n        const sourceVertexOffset = targetVertexOffset % data.vertexData.byteLength;\n        expandedVertexData.set(\n          new Uint8Array(data.vertexData, sourceVertexOffset, vertexComponentSize),\n          targetVertexOffset\n        );\n\n        const targetExpectedOffset = (index * 4 + component) * expectedComponentSize;\n        const sourceExpectedOffset =\n          ((index * componentCount + component) * expectedComponentSize) %\n          data.expectedData.byteLength;\n        expandedExpectedData.set(\n          new Uint8Array(data.expectedData, sourceExpectedOffset, expectedComponentSize),\n          targetExpectedOffset\n        );\n      }\n    }\n\n    return {\n      shaderBaseType: data.shaderBaseType,\n      testComponentCount: maxCount * componentCount,\n      floatTolerance: data.floatTolerance,\n      expectedData: expandedExpectedData.buffer,\n      vertexData: expandedVertexData.buffer,\n    };\n  }\n\n  // Copies `size` bytes from `source` to `target` starting at `offset` each `targetStride`.\n  // (the data in `source` is assumed packed)\n  interleaveVertexDataInto(\n    target: ArrayBuffer,\n    source: ArrayBuffer,\n    { targetStride, offset, size }: { targetStride: number; offset: number; size: number }\n  ) {\n    const t = new Uint8Array(target);\n    for (\n      let sourceOffset = 0, targetOffset = offset;\n      sourceOffset < source.byteLength;\n      sourceOffset += size, targetOffset += targetStride\n    ) {\n      const a = new Uint8Array(source, sourceOffset, size);\n      t.set(a, targetOffset);\n    }\n  }\n\n  createTestAndPipelineData<V, A>(\n    state: VertexLayoutState<V, A>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexLayoutState<V, A & TestData> {\n    // Gather the test data and some additional test state for attribs.\n    return mapStateAttribs(state, (buffer, attrib) => {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n      const formatInfo = kVertexFormatInfo[attrib.format];\n\n      let testData = this.generateTestData(attrib.format);\n      testData = this.expandTestData(testData, maxCount, formatInfo.componentCount);\n\n      return {\n        ...testData,\n        ...attrib,\n      };\n    });\n  }\n\n  createExpectedBG(state: VertexState<{}, TestData>, pipeline: GPURenderPipeline): GPUBindGroup {\n    // Create the bindgroups from that test data\n    const bgEntries: GPUBindGroupEntry[] = [];\n\n    for (const buffer of state) {\n      for (const attrib of buffer.attributes) {\n        const expectedDataBuffer = this.makeBufferWithContents(\n          new Uint8Array(attrib.expectedData),\n          GPUBufferUsage.UNIFORM\n        );\n        bgEntries.push({\n          binding: attrib.shaderLocation,\n          resource: { buffer: expectedDataBuffer },\n        });\n      }\n    }\n\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: bgEntries,\n    });\n  }\n\n  createVertexBuffers(\n    state: VertexLayoutState<{ vbOffset?: number }, TestData>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> {\n    // Create the vertex buffers\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> = [];\n\n    for (const buffer of state) {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n\n      // Fill the vertex data with garbage so that we don't get `0` (which could be a test value)\n      // if the vertex shader loads the vertex data incorrectly.\n      const vertexData = new ArrayBuffer(\n        align(buffer.arrayStride * maxCount + (buffer.vbOffset ?? 0), 4)\n      );\n      new Uint8Array(vertexData).fill(0xc4);\n\n      for (const attrib of buffer.attributes) {\n        const formatInfo = kVertexFormatInfo[attrib.format];\n        this.interleaveVertexDataInto(vertexData, attrib.vertexData, {\n          targetStride: buffer.arrayStride,\n          offset: (buffer.vbOffset ?? 0) + attrib.offset,\n          size: formatInfo.componentCount * formatInfo.bytesPerComponent,\n        });\n      }\n\n      vertexBuffers.push({\n        slot: buffer.slot,\n        buffer: this.makeBufferWithContents(new Uint8Array(vertexData), GPUBufferUsage.VERTEX),\n        vbOffset: buffer.vbOffset,\n        attributes: [],\n      });\n    }\n\n    return vertexBuffers;\n  }\n\n  runTest(\n    buffers: VertexLayoutState<{ vbOffset?: number }, { shaderComponentCount?: number }>,\n    // Default to using 20 vertices and 20 instances so that we cover each of the test data at least\n    // once (at the time of writing the largest testData has 16 values).\n    vertexCount: number = 20,\n    instanceCount: number = 20\n  ) {\n    const testData = this.createTestAndPipelineData(buffers, vertexCount, instanceCount);\n    const pipeline = this.makeTestPipeline(testData, vertexCount, instanceCount);\n    const expectedDataBG = this.createExpectedBG(testData, pipeline);\n    const vertexBuffers = this.createVertexBuffers(testData, vertexCount, instanceCount);\n    this.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, vertexCount, instanceCount);\n  }\n}\n\nexport const g = makeTestGroup(VertexStateTest);\n\ng.test('vertex_format_to_shader_format_conversion')\n  .desc(\n    `Test that the raw data passed in vertex buffers is correctly converted to the input type in the shader. Test for:\n  - all formats\n  - 1 to 4 components in the shader's input type (unused components are filled with 0 and except the 4th with 1)\n  - various locations\n  - various slots`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .combine('shaderComponentCount', [1, 2, 3, 4])\n      .beginSubcases()\n      .combine('slot', [0, 1, kMaxVertexBuffers - 1])\n      .combine('shaderLocation', [0, 1, kMaxVertexAttributes - 1])\n  )\n  .fn(t => {\n    const { format, shaderComponentCount, slot, shaderLocation } = t.params;\n    t.runTest([\n      {\n        slot,\n        arrayStride: 16,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation,\n            format,\n            offset: 0,\n            shaderComponentCount,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('setVertexBuffer_offset_and_attribute_offset')\n  .desc(\n    `Test that the vertex buffer offset and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various setVertexBuffer offsets\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbOffset', [0, 4, 400, 1004])\n      .combine('arrayStride', [128])\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n        return [\n          0,\n          componentSize,\n          componentSize * 2,\n          componentSize * 3,\n          p.arrayStride / 2,\n          p.arrayStride - formatSize - componentSize * 3,\n          p.arrayStride - formatSize - componentSize * 2,\n          p.arrayStride - formatSize - componentSize,\n          p.arrayStride - formatSize,\n        ];\n      })\n  )\n  .fn(t => {\n    const { format, vbOffset, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        vbOffset,\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('non_zero_array_stride_and_attribute_offset')\n  .desc(\n    `Test that the array stride and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various array strides\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .expand('arrayStride', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n\n        return [align(formatSize, 4), align(formatSize, 4) + 4, kMaxVertexBufferArrayStride];\n      })\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n        return new Set(\n          [\n            0,\n            componentSize,\n            p.arrayStride / 2,\n            p.arrayStride - formatSize - componentSize,\n            p.arrayStride - formatSize,\n          ].map(offset => clamp(offset, { min: 0, max: p.arrayStride - formatSize }))\n        );\n      })\n  )\n  .fn(t => {\n    const { format, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('buffers_with_varying_step_mode')\n  .desc(\n    `Test buffers with varying step modes in the same vertex state.\n  - Various combination of step modes`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('stepModes', [\n        ['instance'],\n        ['vertex', 'vertex', 'instance'],\n        ['instance', 'vertex', 'instance'],\n        ['vertex', 'instance', 'vertex', 'vertex'],\n      ])\n  )\n  .fn(t => {\n    const { stepModes } = t.params;\n    const state = (stepModes as GPUInputStepMode[]).map((stepMode, i) => ({\n      slot: i,\n      arrayStride: 4,\n      stepMode,\n      attributes: [\n        {\n          shaderLocation: i,\n          format: 'float32' as const,\n          offset: 0,\n        },\n      ],\n    }));\n    t.runTest(state);\n  });\n\ng.test('vertex_buffer_used_multiple_times_overlapped')\n  .desc(\n    `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer overlapping.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbCount', [2, 3, kMaxVertexBuffers])\n      .combine('additionalVBOffset', [0, 4, 120])\n  )\n  .fn(t => {\n    const { format, vbCount, additionalVBOffset } = t.params;\n    const kVertexCount = 20;\n    const kInstanceCount = 1;\n    const formatInfo = kVertexFormatInfo[format];\n    const formatByteSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n    const alignedFormatByteSize = align(formatByteSize, 4);\n\n    // In this test we want to test using the same vertex buffer for multiple different attributes.\n    // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n    //    a0, a1, a2, a3, ..., a<baseDataVertexCount>\n    // We also create the expected data for the vertex fetching from that buffer so we can modify it\n    // below.\n    const baseDataVertexCount = kVertexCount + vbCount - 1;\n    const baseData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: alignedFormatByteSize,\n          stepMode: 'vertex',\n          vbOffset: additionalVBOffset,\n          attributes: [{ shaderLocation: 0, format, offset: 0 }],\n        },\n      ],\n      baseDataVertexCount,\n      kInstanceCount\n    );\n    const vertexBuffer = t.createVertexBuffers(baseData, baseDataVertexCount, kInstanceCount)[0]\n      .buffer;\n\n    // We are going to bind the vertex buffer multiple times, each time at a different offset that's\n    // a multiple of the data size. So what should be fetched by the vertex shader is:\n    //    - attrib0: a0, a1, ..., a19\n    //    - attrib1: a1, a2, ..., a20\n    //    - attrib2: a2, a3, ..., a21\n    //    etc.\n    // We re-create the test data by:\n    //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n    //      different offsets.\n    //   2) selecting what parts of the expectedData each attribute will see in the expectedData for\n    //      the full vertex buffer.\n    const baseTestData = baseData[0].attributes[0];\n    assert(baseTestData.testComponentCount === formatInfo.componentCount * baseDataVertexCount);\n    const expectedDataBytesPerVertex = baseTestData.expectedData.byteLength / baseDataVertexCount;\n\n    const testData: VertexLayoutState<{}, TestData> = [];\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset: number }, {}> = [];\n    for (let i = 0; i < vbCount; i++) {\n      vertexBuffers.push({\n        buffer: vertexBuffer,\n        slot: i,\n        vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n        attributes: [],\n      });\n\n      testData.push({\n        slot: i,\n        arrayStride: alignedFormatByteSize,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: i,\n            format,\n            offset: 0,\n\n            shaderBaseType: baseTestData.shaderBaseType,\n            floatTolerance: baseTestData.floatTolerance,\n            // Select vertices [i, i + kVertexCount]\n            testComponentCount: kVertexCount * formatInfo.componentCount,\n            expectedData: baseTestData.expectedData.slice(\n              expectedDataBytesPerVertex * i,\n              expectedDataBytesPerVertex * (kVertexCount + i)\n            ),\n            vertexData: new ArrayBuffer(0),\n          },\n        ],\n      });\n    }\n\n    // Run the test with the modified test data.\n    const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n    const expectedDataBG = t.createExpectedBG(testData, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n  });\n\ng.test('vertex_buffer_used_multiple_times_interleaved')\n  .desc(\n    `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer interleaved.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbCount', [2, 3, kMaxVertexBuffers])\n      .combine('additionalVBOffset', [0, 4, 120])\n  )\n  .fn(t => {\n    const { format, vbCount, additionalVBOffset } = t.params;\n    const kVertexCount = 20;\n    const kInstanceCount = 1;\n    const formatInfo = kVertexFormatInfo[format];\n    const formatByteSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n    const alignedFormatByteSize = align(formatByteSize, 4);\n\n    // Create data for a single vertex buffer with many attributes, that will be split between\n    // many vertexbuffers set at different offsets.\n\n    // In this test we want to test using the same vertex buffer for multiple different attributes.\n    // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n    //    a0, a0, a0, a1, a1, a1, ...\n    // To do that we create a single vertex buffer with `vbCount` attributes that all have the same\n    // format.\n    const attribs: GPUVertexAttribute[] = [];\n    for (let i = 0; i < vbCount; i++) {\n      attribs.push({ format, offset: i * alignedFormatByteSize, shaderLocation: i });\n    }\n    const baseData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: alignedFormatByteSize * vbCount,\n          stepMode: 'vertex',\n          vbOffset: additionalVBOffset,\n          attributes: attribs,\n        },\n      ],\n      kVertexCount,\n      kInstanceCount\n    );\n    const vertexBuffer = t.createVertexBuffers(baseData, kVertexCount, kInstanceCount)[0].buffer;\n\n    // Then we recreate test data by:\n    //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n    //      different offsets.\n    //   2) have multiple vertex buffer, each with one attributes that will expect a0, a1, ...\n    const testData: VertexLayoutState<{}, TestData> = [];\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset: number }, {}> = [];\n    for (let i = 0; i < vbCount; i++) {\n      vertexBuffers.push({\n        slot: i,\n        buffer: vertexBuffer,\n        vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n        attributes: [],\n      });\n      testData.push({\n        ...baseData[0],\n        slot: i,\n        attributes: [{ ...baseData[0].attributes[i], offset: 0 }],\n      });\n    }\n\n    // Run the test with the modified test data.\n    const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n    const expectedDataBG = t.createExpectedBG(testData, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n  });\n\ng.test('max_buffers_and_attribs')\n  .desc(\n    `Test a vertex state that loads as many attributes and buffers as possible.\n  - For each format.\n  TODO find a way to test maxAttribs. Right now this test is gated on kMaxUniformBuffersPerStage\n  `\n  )\n  .paramsSubcasesOnly(u => u.combine('format', kVertexFormats))\n  .fn(t => {\n    const { format } = t.params;\n    // The fixture uses one uniform buffer per attribute, so we can't test more than\n    // kMaxUniformBuffersPerStage attributes.\n    const maxTestableAttribs = Math.min(\n      kMaxVertexAttributes,\n      kPerStageBindingLimits['uniformBuf'].max\n    );\n\n    const attributesPerBuffer = Math.ceil(maxTestableAttribs / kMaxVertexBuffers);\n    let attributesEmitted = 0;\n\n    const state: VertexLayoutState<{}, {}> = [];\n    for (let i = 0; i < kMaxVertexBuffers; i++) {\n      const attributes: GPUVertexAttribute[] = [];\n      for (let j = 0; j < attributesPerBuffer && attributesEmitted < maxTestableAttribs; j++) {\n        attributes.push({ format, offset: 0, shaderLocation: attributesEmitted });\n        attributesEmitted++;\n      }\n      state.push({\n        slot: i,\n        stepMode: 'vertex',\n        arrayStride: 32,\n        attributes,\n      });\n    }\n    t.runTest(state);\n  });\n\ng.test('array_stride_zero')\n  .desc(\n    `Test that arrayStride 0 correctly uses the same data for all vertex/instances, while another test vertex buffer with arrayStrude != 0 gets different data.\n  - Test for all formats\n  - Test for both step modes`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('stepMode', ['vertex', 'instance'] as const)\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const componentSize = formatInfo.bytesPerComponent;\n        const formatSize = componentSize * formatInfo.componentCount;\n        return new Set([\n          0,\n          componentSize,\n          componentSize * 2,\n          componentSize * 3,\n          kMaxVertexBufferArrayStride / 2,\n          kMaxVertexBufferArrayStride - formatSize - componentSize * 3,\n          kMaxVertexBufferArrayStride - formatSize - componentSize * 2,\n          kMaxVertexBufferArrayStride - formatSize - componentSize,\n          kMaxVertexBufferArrayStride - formatSize,\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, stepMode, offset } = t.params;\n    const kCount = 10;\n\n    // Create the stride 0 part of the test, first by faking a single vertex being drawn and\n    // then expanding the data to cover kCount vertex / instances\n    const stride0TestData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: 2048,\n          stepMode,\n          vbOffset: offset, // used to push data in the vertex buffer\n          attributes: [{ format, offset: 0, shaderLocation: 0 }],\n        },\n      ],\n      1,\n      1\n    )[0];\n    const stride0VertexBuffer = t.createVertexBuffers([stride0TestData], kCount, kCount)[0];\n\n    // Expand the stride0 test data to have kCount values for expectedData.\n    const originalData = stride0TestData.attributes[0].expectedData;\n    const expandedData = new ArrayBuffer(kCount * originalData.byteLength);\n    for (let i = 0; i < kCount; i++) {\n      new Uint8Array(expandedData, originalData.byteLength * i).set(new Uint8Array(originalData));\n    }\n\n    // Fixup stride0TestData to use arrayStride 0.\n    stride0TestData.attributes[0].offset = offset;\n    stride0TestData.attributes[0].expectedData = expandedData;\n    stride0TestData.attributes[0].testComponentCount *= kCount;\n    stride0TestData.arrayStride = 0;\n    stride0VertexBuffer.vbOffset = 0;\n\n    // Create the part of the state that will be varying for each vertex / instance\n    const varyingTestData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 1,\n          arrayStride: 32,\n          stepMode,\n          attributes: [{ format, offset: 0, shaderLocation: 1 }],\n        },\n      ],\n      kCount,\n      kCount\n    )[0];\n    const varyingVertexBuffer = t.createVertexBuffers([varyingTestData], kCount, kCount)[0];\n\n    // Run the test with the merged test state.\n    const state = [stride0TestData, varyingTestData];\n    const vertexBuffers = [stride0VertexBuffer, varyingVertexBuffer];\n\n    const pipeline = t.makeTestPipeline(state, kCount, kCount);\n    const expectedDataBG = t.createExpectedBG(state, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kCount, kCount);\n  });\n\ng.test('discontiguous_location_and_attribs')\n  .desc('Test that using far away slots / shaderLocations works as expected')\n  .fn(t => {\n    t.runTest([\n      {\n        slot: kMaxVertexBuffers - 1,\n        arrayStride: 4,\n        stepMode: 'vertex',\n        attributes: [\n          { format: 'uint8x2', offset: 2, shaderLocation: 0 },\n          { format: 'uint8x2', offset: 0, shaderLocation: 8 },\n        ],\n      },\n      {\n        slot: 1,\n        arrayStride: 16,\n        stepMode: 'instance',\n        vbOffset: 1000,\n        attributes: [{ format: 'uint32x4', offset: 0, shaderLocation: kMaxVertexAttributes - 1 }],\n      },\n    ]);\n  });\n\ng.test('overlapping_attributes')\n  .desc(\n    `Test that overlapping attributes in the same vertex buffer works\n   - Test for all formats\n  TODO find a way to test maxAttribs. Right now this test is gated on kMaxUniformBuffersPerStage`\n  )\n  .paramsSubcasesOnly(u => u.combine('format', kVertexFormats))\n  .fn(t => {\n    const { format } = t.params;\n    // The fixture uses one uniform buffer per attribute, so we can't test more than\n    // kMaxUniformBuffersPerStage attributes.\n    const maxTestableAttribs = Math.min(\n      kMaxVertexAttributes,\n      kPerStageBindingLimits['uniformBuf'].max\n    );\n\n    const attributes: GPUVertexAttribute[] = [];\n    for (let i = 0; i < maxTestableAttribs; i++) {\n      attributes.push({ format, offset: 0, shaderLocation: i });\n    }\n\n    t.runTest([\n      {\n        slot: 0,\n        stepMode: 'vertex',\n        arrayStride: 32,\n        attributes,\n      },\n    ]);\n  });\n"],"file":"correctness.spec.js"}