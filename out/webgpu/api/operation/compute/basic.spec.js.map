{"version":3,"sources":["../../../../../src/webgpu/api/operation/compute/basic.spec.ts"],"names":["description","makeTestGroup","DefaultLimits","GPUTest","checkElementsEqualGenerated","g","test","fn","t","data","Uint32Array","src","device","createBuffer","mappedAtCreation","size","usage","GPUBufferUsage","COPY_DST","STORAGE","getMappedRange","set","unmap","dst","COPY_SRC","pipeline","createComputePipeline","compute","module","createShaderModule","code","entryPoint","bg","createBindGroup","entries","binding","resource","buffer","offset","layout","getBindGroupLayout","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","queue","submit","finish","expectGPUBufferValuesEqual","desc","params","u","combine","maxComputePerDimensionDispatchSize","beginSubcases","expand","p","maxComputeWorkgroupSize","largeDimension","val","badVal","wgSize","workgroupSize","bufferLength","dispatchSize","bufferByteSize","BYTES_PER_ELEMENT","dims","wgSizes","expectGPUBufferValuesPassCheck","a","i","type","typedLength","destroy"],"mappings":"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","sourcesContent":["export const description = `\nBasic command buffer compute tests.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { DefaultLimits } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsEqualGenerated } from '../../../util/check_contents.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('memcpy').fn(async t => {\n  const data = new Uint32Array([0x01020304]);\n\n  const src = t.device.createBuffer({\n    mappedAtCreation: true,\n    size: 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  new Uint32Array(src.getMappedRange()).set(data);\n  src.unmap();\n\n  const dst = t.device.createBuffer({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const pipeline = t.device.createComputePipeline({\n    compute: {\n      module: t.device.createShaderModule({\n        code: `\n          [[block]] struct Data {\n              value : u32;\n          };\n\n          [[group(0), binding(0)]] var<storage, read> src : Data;\n          [[group(0), binding(1)]] var<storage, read_write> dst : Data;\n\n          [[stage(compute), workgroup_size(1)]] fn main() {\n            dst.value = src.value;\n            return;\n          }\n        `,\n      }),\n      entryPoint: 'main',\n    },\n  });\n\n  const bg = t.device.createBindGroup({\n    entries: [\n      { binding: 0, resource: { buffer: src, offset: 0, size: 4 } },\n      { binding: 1, resource: { buffer: dst, offset: 0, size: 4 } },\n    ],\n    layout: pipeline.getBindGroupLayout(0),\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bg);\n  pass.dispatch(1);\n  pass.endPass();\n  t.device.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(dst, data);\n});\n\ng.test('large_dispatch')\n  .desc(`Test reasonably-sized large dispatches (see also: stress tests).`)\n  .params(u =>\n    u\n      // Reasonably-sized powers of two, and some stranger larger sizes.\n      .combine('dispatchSize', [\n        256,\n        2048,\n        315,\n        628,\n        2179,\n        DefaultLimits.maxComputePerDimensionDispatchSize,\n      ])\n      // Test some reasonable workgroup sizes.\n      .beginSubcases()\n      // 0 == x axis; 1 == y axis; 2 == z axis.\n      .combine('largeDimension', [0, 1, 2] as const)\n      .expand('workgroupSize', p => [\n        1,\n        2,\n        8,\n        32,\n        DefaultLimits.maxComputeWorkgroupSize[p.largeDimension],\n      ])\n  )\n  .fn(async t => {\n    // The output storage buffer is filled with this value.\n    const val = 0x01020304;\n    const badVal = 0xbaadf00d;\n\n    const wgSize = t.params.workgroupSize;\n    const bufferLength = t.params.dispatchSize * wgSize;\n    const bufferByteSize = Uint32Array.BYTES_PER_ELEMENT * bufferLength;\n    const dst = t.device.createBuffer({\n      size: bufferByteSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    // Only use one large dimension and workgroup size in the dispatch\n    // call to keep the size of the test reasonable.\n    const dims = [1, 1, 1];\n    dims[t.params.largeDimension] = t.params.dispatchSize;\n    const wgSizes = [1, 1, 1];\n    wgSizes[t.params.largeDimension] = t.params.workgroupSize;\n    const pipeline = t.device.createComputePipeline({\n      compute: {\n        module: t.device.createShaderModule({\n          code: `\n            [[block]] struct OutputBuffer {\n              value : array<u32>;\n            };\n\n            [[group(0), binding(0)]] var<storage, read_write> dst : OutputBuffer;\n\n            [[stage(compute), workgroup_size(${wgSizes[0]}, ${wgSizes[1]}, ${wgSizes[2]})]]\n            fn main(\n              [[builtin(global_invocation_id)]] GlobalInvocationID : vec3<u32>\n            ) {\n              var xExtent : u32 = ${dims[0]}u * ${wgSizes[0]}u;\n              var yExtent : u32 = ${dims[1]}u * ${wgSizes[1]}u;\n              var zExtent : u32 = ${dims[2]}u * ${wgSizes[2]}u;\n              var index : u32 = (\n                GlobalInvocationID.z * xExtent * yExtent +\n                GlobalInvocationID.y * xExtent +\n                GlobalInvocationID.x);\n              var val : u32 = ${val}u;\n              // Trivial error checking in the indexing and invocation.\n              if (GlobalInvocationID.x > xExtent ||\n                  GlobalInvocationID.y > yExtent ||\n                  GlobalInvocationID.z > zExtent) {\n                val = ${badVal}u;\n              }\n              dst.value[index] = val;\n            }\n          `,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const bg = t.device.createBindGroup({\n      entries: [{ binding: 0, resource: { buffer: dst, offset: 0, size: bufferByteSize } }],\n      layout: pipeline.getBindGroupLayout(0),\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatch(dims[0], dims[1], dims[2]);\n    pass.endPass();\n    t.device.queue.submit([encoder.finish()]);\n\n    t.expectGPUBufferValuesPassCheck(dst, a => checkElementsEqualGenerated(a, i => val), {\n      type: Uint32Array,\n      typedLength: bufferLength,\n    });\n\n    dst.destroy();\n  });\n"],"file":"basic.spec.js"}